var tipuesearch = {"pages":[{"title":" x3d2 ","text":"x3d2 A re-implementation of the Xcompact3d framework. Developer Info Xcompact3d team","tags":"home","loc":"index.html"},{"title":"poisson_fft_t – x3d2 ","text":"type, public, abstract :: poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_backward ), public, deferred :: fft_backward subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_postprocess ), public, deferred :: fft_postprocess subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"type/poisson_fft_t.html"},{"title":"tdsops_t – x3d2 ","text":"type, public :: tdsops_t Tridiagonal Solver Operators class. Operator arrays are preprocessed in this class based on the arguments\nprovided. dist_fw and dist_bw are used in the first phase of the\ndistributed tridiagonal solver algorithm. dist_sa and dist_sc are used\nin the final substitution phase. See the kernels_dist.f90 files in the\nrelevant backend folders.\ncoeff arrays define the specific rules of building the RHS\ncorresponding to the tridiagonal system to be solved, and used only in\nthe first phase of the distributed algorithm when building the RHS.\nIf a boundary condition is defined then coeffs_s and coeffs_e differ\nfrom coeffs array and define the RHS rule for the first and last 4\nentries in the tridiagonal system (n_halo = 4). This class does not know about the current rank or its relative\nlocation among other ranks. All the operator arrays here are used when\nexecuting a distributed tridiagonal solver phase one or two. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp logical, public :: periodic integer, public :: tds_n integer, public :: dir integer, public :: n_halo Constructor public        interface tdsops_t public  function tdsops_init (tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: tds_n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: preprocess_thom public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b procedure, public :: preprocess_dist public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","loc":"type/tdsops_t.html"},{"title":"dirps_t – x3d2 ","text":"type, public :: dirps_t Directional tridiagonal solver container. This class contains the preprocessed tridiagonal solvers for operating\nin each coordinate direction. Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: dir","tags":"","loc":"type/dirps_t.html"},{"title":"cuda_tdsops_t – x3d2 ","text":"type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Regular tdsops_t class is initiated and the coefficient arrays are\ncopied into device arrays so that cuda kernels can use them. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp logical, public :: periodic integer, public :: tds_n integer, public :: dir integer, public :: n_halo real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: thom_f_dev (:) real(kind=dp), public, device, allocatable :: thom_s_dev (:) real(kind=dp), public, device, allocatable :: thom_w_dev (:) real(kind=dp), public, device, allocatable :: thom_p_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public        interface cuda_tdsops_t public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym procedure, public :: preprocess_thom public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b procedure, public :: preprocess_dist public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","loc":"type/cuda_tdsops_t.html"},{"title":"omp_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor public        interface omp_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: fft_forward => fft_forward_omp public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_backward => fft_backward_omp public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_postprocess => fft_postprocess_omp public  subroutine fft_postprocess_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"type/omp_poisson_fft_t.html"},{"title":"time_intg_t – x3d2 ","text":"type, public :: time_intg_t Components Type Visibility Attributes Name Initial integer, public :: method integer, public :: istep integer, public :: istage integer, public :: order integer, public :: nstep integer, public :: nstage integer, public :: nvars integer, public :: nolds real(kind=dp), public :: coeffs (4,4) real(kind=dp), public :: rk_b (4,4) real(kind=dp), public :: rk_a (3,3,4) character(len=3), public :: sname type( flist_t ), public, allocatable :: olds (:,:) type( flist_t ), public, allocatable :: curr (:) type( flist_t ), public, allocatable :: deriv (:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator procedure( stepper_func ), public, pointer :: stepper => null() Constructor public        interface time_intg_t public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Type-Bound Procedures procedure, public :: finalize public  subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self procedure, public :: step public  subroutine step (self, u, v, w, du, dv, dw, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self class( field_t ), intent(inout), target :: u class( field_t ), intent(inout), target :: v class( field_t ), intent(inout), target :: w class( field_t ), intent(in), target :: du class( field_t ), intent(in), target :: dv class( field_t ), intent(in), target :: dw real(kind=dp), intent(in) :: dt procedure, public :: runge_kutta private  subroutine runge_kutta(self, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self real(kind=dp), intent(in) :: dt procedure, public :: adams_bashforth private  subroutine adams_bashforth(self, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self real(kind=dp), intent(in) :: dt","tags":"","loc":"type/time_intg_t.html"},{"title":"field_t – x3d2 ","text":"type, public :: field_t Memory block type holding both a data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public        interface field_t public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Type-Bound Procedures procedure, public :: set_shape public  subroutine set_shape (self, dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3) procedure, public :: set_data_loc public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc","tags":"","loc":"type/field_t.html"},{"title":"cuda_allocator_t – x3d2 ","text":"type, public, extends( allocator_t ) :: cuda_allocator_t Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( mesh_t ), public, pointer :: mesh The pointer to the first block on the list.  Non associated if\nthe list is empty class( field_t ), public, pointer :: first => null() Constructor public        interface cuda_allocator_t public  function cuda_allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh integer, intent(in) :: sz Return Value type( cuda_allocator_t ) Type-Bound Procedures procedure, public :: get_block public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self procedure, public :: compute_padded_dims public  subroutine compute_padded_dims (self, sz) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: sz procedure, public :: create_block => create_cuda_block public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"type/cuda_allocator_t.html"},{"title":"cuda_field_t – x3d2 ","text":"type, public, extends( field_t ) :: cuda_field_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, device, pointer, contiguous :: data_d (:,:,:) Constructor public        interface cuda_field_t public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Type-Bound Procedures procedure, public :: set_data_loc public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc procedure, public :: set_shape => set_shape_cuda public  subroutine set_shape_cuda (self, dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","loc":"type/cuda_field_t.html"},{"title":"omp_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: omp_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public        interface omp_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian) procedure, public :: alloc_tdsops => alloc_omp_tdsops public  subroutine alloc_omp_tdsops (self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_omp public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_omp public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_omp public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve => tds_solve_omp public  subroutine tds_solve_omp (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_omp public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_omp public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: sum_zintox => sum_zintox_omp public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: vecadd => vecadd_omp public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: scalar_product => scalar_product_omp public  function scalar_product_omp (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: copy_data_to_f => copy_data_to_f_omp public  subroutine copy_data_to_f_omp (self, f, data) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data procedure, public :: copy_f_to_data => copy_f_to_data_omp public  subroutine copy_f_to_data_omp (self, data, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_omp_poisson_fft public  subroutine init_omp_poisson_fft (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: transeq_omp_dist public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"type/omp_backend_t.html"},{"title":"solver_t – x3d2 ","text":"type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Procedures defined here that are part of the Incompact3D algorithm\nare: transeq, divergence, poisson, and gradient. The operations these high level procedures require are provided by\nthe relavant backend implementations. transeq procedure obtains the derivations in x, y, and z directions\nusing the transeq_x, transeq_y, and transeq_z operations provided by\nthe backend.\nThere are two different algorithms available for this operation, a\ndistributed algorithm and the Thomas algorithm. At the solver class\nlevel it isn't known which algorithm will be executed, that is decided\nat run time and therefore backend implementations are responsible for\nexecuting the right subroutines. Allocator is responsible from giving us a field sized array when\nrequested. For example, when the derivations in x direction are\ncompleted and we are ready for the y directional derivatives, we need\nthree fields to reorder and store the velocities in y direction. Also,\nwe need three more fields for storing the results, and the get_block\nmethod of the allocator is used to arrange all these memory\nassignments. Later, when a field is no more required, release_block\nmethod of the allocator can be used to make this field available\nfor later use. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu integer, public :: n_iters integer, public :: n_output integer, public :: ngrid class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w class( base_backend_t ), public, pointer :: backend class( mesh_t ), public, pointer :: mesh type( time_intg_t ), public :: time_integrator type( allocator_t ), public, pointer :: host_allocator type( dirps_t ), public, pointer :: xdirps type( dirps_t ), public, pointer :: ydirps type( dirps_t ), public, pointer :: zdirps procedure( poisson_solver ), public, pointer :: poisson => null() Constructor public        interface solver_t public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Type-Bound Procedures procedure, public :: transeq public  subroutine transeq (self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: divergence_v2p public  subroutine divergence_v2p (self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: gradient_p2v public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure procedure, public :: curl public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: output public  subroutine output (self, t) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t procedure, public :: run public  subroutine run (self) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(inout) :: self","tags":"","loc":"type/solver_t.html"},{"title":"allocator_t – x3d2 ","text":"type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size m_allocator objects: ---- ---- ---- ---- ---- ---- ... -->| id = 1 | data | next |-->| id = 0 | data | next |--> null () ---- ---- ---- ---- ---- ---- the last block's next pointer being non associated. User code can request access to a memory block by using the\ntype bound procedure get_block .  If the list is\nnot empty, a pointer to the first block on the list is\nreturned and the block is detached from the list.  If the list\nis empty (i.e. all initially allocated blocks are currently\nreferenced to) then a new block is allocated before a pointer\nto it is returned. In order to reuse memory it is important that user code\nrelease blocks when they are not needed anymore.  This is done\nby calling the type bound procedure release_block .  The\nreleased block is then pushed in front of the block list. Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( mesh_t ), public, pointer :: mesh The pointer to the first block on the list.  Non associated if\nthe list is empty class( field_t ), public, pointer :: first => null() Constructor public        interface allocator_t public  function allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh integer, intent(in) :: sz Return Value type( allocator_t ) Type-Bound Procedures procedure, public :: get_block public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: create_block public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self procedure, public :: compute_padded_dims public  subroutine compute_padded_dims (self, sz) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: sz","tags":"","loc":"type/allocator_t.html"},{"title":"flist_t – x3d2 ","text":"type, public :: flist_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr","tags":"","loc":"type/flist_t.html"},{"title":"cuda_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: cuda_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public        interface cuda_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian) procedure, public :: alloc_tdsops => alloc_cuda_tdsops public  subroutine alloc_cuda_tdsops (self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_cuda public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_cuda public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_cuda public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve => tds_solve_cuda public  subroutine tds_solve_cuda (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_cuda public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_cuda public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y procedure, public :: sum_zintox => sum_zintox_cuda public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z procedure, public :: vecadd => vecadd_cuda public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: scalar_product => scalar_product_cuda public  function scalar_product_cuda (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: copy_data_to_f => copy_data_to_f_cuda public  subroutine copy_data_to_f_cuda (self, f, data) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data procedure, public :: copy_f_to_data => copy_f_to_data_cuda public  subroutine copy_f_to_data_cuda (self, data, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_cuda_poisson_fft public  subroutine init_cuda_poisson_fft (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: transeq_cuda_dist public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads procedure, public :: transeq_cuda_thom public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve_dist public  subroutine tds_solve_dist (self, du, u, dirps, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"type/cuda_backend_t.html"},{"title":"base_backend_t – x3d2 ","text":"type, public, abstract :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. For example, transport equation in solver class evaluates the\nderivatives in x, y, and z directions, and reorders the input\nfields as required. Then finally, combines all the directional\nderivatives to obtain the divergence of U*. All these high level operations solver class executes are\ndefined here using the abstract interfaces. Every backend\nimplementation extends the present abstact backend class to\ndefine the specifics of these operations based on the target\narchitecture. Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_y subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_z subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure( tds_solve ), public, deferred :: tds_solve subroutine tds_solve(self, du, u, dirps, tdsops) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops procedure( reorder ), public, deferred :: reorder subroutine reorder(self, u_, u, direction) Prototype reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure( sum_intox ), public, deferred :: sum_yintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( sum_intox ), public, deferred :: sum_zintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( vecadd ), public, deferred :: vecadd subroutine vecadd(self, a, x, b, y) Prototype adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure( scalar_product ), public, deferred :: scalar_product function scalar_product(self, x, y) result(s) Prototype Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure( copy_data_to_f ), public, deferred :: copy_data_to_f subroutine copy_data_to_f(self, f, data) Prototype Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory. Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data procedure( copy_f_to_data ), public, deferred :: copy_f_to_data subroutine copy_f_to_data(self, data, f) Prototype Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure( alloc_tdsops ), public, deferred :: alloc_tdsops subroutine alloc_tdsops(self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure( init_poisson_fft ), public, deferred :: init_poisson_fft subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian)","tags":"","loc":"type/base_backend_t.html"},{"title":"cuda_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: by_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: az_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev Wave numbers in x, y, and z integer, public :: plan3D_fw Forward and backward FFT transform plans integer, public :: plan3D_bw Forward and backward FFT transform plans type(cudaLibXtDesc), public, pointer :: xtdesc cuFFTMp object manages decomposition and data storage Constructor public        interface cuda_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: fft_forward => fft_forward_cuda public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_backward => fft_backward_cuda public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_postprocess => fft_postprocess_cuda public  subroutine fft_postprocess_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"type/cuda_poisson_fft_t.html"},{"title":"geo_t – x3d2 ","text":"type, public :: geo_t Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(3) :: d real(kind=dp), public, dimension(3) :: L","tags":"","loc":"type/geo_t.html"},{"title":"parallel_t – x3d2 ","text":"type, public :: parallel_t Components Type Visibility Attributes Name Initial integer, public :: nrank integer, public :: nproc integer, public, dimension(3) :: nrank_dir integer, public, dimension(3) :: nproc_dir integer, public, dimension(3) :: n_offset integer, public, dimension(3) :: pnext integer, public, dimension(3) :: pprev Type-Bound Procedures procedure, public :: is_root public pure function is_root (self) result(is_root_rank) Returns whether or not the current rank is the root rank Arguments Type Intent Optional Attributes Name class( parallel_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/parallel_t.html"},{"title":"mesh_t – x3d2 ","text":"type, public :: mesh_t Components Type Visibility Attributes Name Initial type( geo_t ), public, allocatable :: geo type( parallel_t ), public, allocatable :: par Constructor public        interface mesh_t public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z Return Value type( mesh_t ) Type-Bound Procedures procedure, public :: get_SZ => get_sz public pure function get_sz (self) result(sz) Getter for parameter SZ Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self Return Value integer procedure, public :: get_dims public pure function get_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_global_dims public pure function get_global_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_n_groups_dir public pure function get_n_groups_dir (self, dir) result(n_groups) Getter for the number of groups for fields in direction dir Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer procedure, public :: get_n_groups_phi public pure function get_n_groups_phi (self, phi) result(n_groups) Getter for the number of groups for fields phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer generic, public :: get_n_groups => get_n_groups_dir , get_n_groups_phi public pure function get_n_groups_dir (self, dir) result(n_groups) Getter for the number of groups for fields in direction dir Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer public pure function get_n_groups_phi (self, phi) result(n_groups) Getter for the number of groups for fields phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer procedure, public :: get_field_dims_dir public pure function get_field_dims_dir (self, dir, data_loc) result(dims) Getter for the dimensions of an array directed along dir where data would be located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_field_dims_phi public pure function get_field_dims_phi (self, phi) result(dims) Getter for the dimensions of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) procedure, public :: get_field_dims_phi_dataloc public pure function get_field_dims_phi_dataloc (self, phi, data_loc) result(dims) Getter for the dimensions of field phi where data is located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi integer, intent(in) :: data_loc Return Value integer, dimension(3) generic, public :: get_field_dims => get_field_dims_dir , get_field_dims_phi , get_field_dims_phi_dataloc public pure function get_field_dims_dir (self, dir, data_loc) result(dims) Getter for the dimensions of an array directed along dir where data would be located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_field_dims_phi (self, phi) result(dims) Getter for the dimensions of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) public pure function get_field_dims_phi_dataloc (self, phi, data_loc) result(dims) Getter for the dimensions of field phi where data is located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_n_dir public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer procedure, public :: get_n_phi public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer generic, public :: get_n => get_n_dir , get_n_phi public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer procedure, public :: get_padded_dims_phi public pure function get_padded_dims_phi (self, phi) result(dims_padded) Getter for padded dimensions for field phi\nGets the field direction from the field itself Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) procedure, public :: get_padded_dims_dir public pure function get_padded_dims_dir (self, dir) result(dims_padded) Getter for padded dimensions with structure in dir direction Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer, dimension(3) generic, public :: get_padded_dims => get_padded_dims_dir , get_padded_dims_phi public pure function get_padded_dims_dir (self, dir) result(dims_padded) Getter for padded dimensions with structure in dir direction Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer, dimension(3) public pure function get_padded_dims_phi (self, phi) result(dims_padded) Getter for padded dimensions for field phi\nGets the field direction from the field itself Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) procedure, public :: get_coordinates public pure function get_coordinates (self, i, j, k) result(xloc) Get the physical location of a cell center with i,j,k local indices Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp), dimension(3) procedure, public :: set_sz public  subroutine set_sz (self, sz) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in) :: sz procedure, public :: set_padded_dims public  subroutine set_padded_dims (self, vert_dims) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in), dimension(3) :: vert_dims","tags":"","loc":"type/mesh_t.html"},{"title":"fft_forward – x3d2","text":"interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","loc":"interface/fft_forward.html"},{"title":"fft_backward – x3d2","text":"interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","loc":"interface/fft_backward.html"},{"title":"fft_postprocess – x3d2","text":"interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self","tags":"","loc":"interface/fft_postprocess.html"},{"title":"stepper_func – x3d2","text":"interface public  subroutine stepper_func(self, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self real(kind=dp), intent(in) :: dt","tags":"","loc":"interface/stepper_func.html"},{"title":"poisson_solver – x3d2","text":"interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"interface/poisson_solver.html"},{"title":"transeq_ders – x3d2","text":"interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","loc":"interface/transeq_ders.html"},{"title":"tds_solve – x3d2","text":"interface public  subroutine tds_solve(self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","loc":"interface/tds_solve.html"},{"title":"reorder – x3d2","text":"interface public  subroutine reorder(self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction Description reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast.","tags":"","loc":"interface/reorder.html"},{"title":"sum_intox – x3d2","text":"interface public  subroutine sum_intox(self, u, u_) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ Description sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields.","tags":"","loc":"interface/sum_intox.html"},{"title":"vecadd – x3d2","text":"interface public  subroutine vecadd(self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y Description adds two vectors together: y = a x + b y","tags":"","loc":"interface/vecadd.html"},{"title":"scalar_product – x3d2","text":"interface public  function scalar_product(self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Description Calculates the scalar product of two input fields","tags":"","loc":"interface/scalar_product.html"},{"title":"copy_data_to_f – x3d2","text":"interface public  subroutine copy_data_to_f(self, f, data) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data Description Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory.","tags":"","loc":"interface/copy_data_to_f.html"},{"title":"copy_f_to_data – x3d2","text":"interface public  subroutine copy_f_to_data(self, data, f) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f Description Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host","tags":"","loc":"interface/copy_f_to_data.html"},{"title":"alloc_tdsops – x3d2","text":"interface public  subroutine alloc_tdsops(self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"interface/alloc_tdsops.html"},{"title":"init_poisson_fft – x3d2","text":"interface public  subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"interface/init_poisson_fft.html"},{"title":"base_init – x3d2","text":"public  subroutine base_init(self, mesh, xdirps, ydirps, zdirps) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/base_init.html"},{"title":"waves_set – x3d2","text":"public  subroutine waves_set(self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Ref. JCP 228 (2009), 5989–6015, Sec 4 Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/waves_set.html"},{"title":"tdsops_init – x3d2","text":"public  function tdsops_init(tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: tds_n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function","tags":"","loc":"proc/tdsops_init.html"},{"title":"get_tds_n – x3d2","text":"public pure function get_tds_n(mesh, dir, from_to) result(tds_n) Get the tds_n size based on the from_to value (and the mesh) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh integer, intent(in) :: dir character(len=*), intent(in), optional :: from_to Return Value integer","tags":"","loc":"proc/get_tds_n.html"},{"title":"deriv_1st – x3d2","text":"public  subroutine deriv_1st(self, delta, scheme, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/deriv_1st.html"},{"title":"deriv_2nd – x3d2","text":"public  subroutine deriv_2nd(self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/deriv_2nd.html"},{"title":"interpl_mid – x3d2","text":"public  subroutine interpl_mid(self, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/interpl_mid.html"},{"title":"stagder_1st – x3d2","text":"public  subroutine stagder_1st(self, delta, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym","tags":"","loc":"proc/stagder_1st.html"},{"title":"preprocess_dist – x3d2","text":"public  subroutine preprocess_dist(self, dist_b) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","loc":"proc/preprocess_dist.html"},{"title":"preprocess_thom – x3d2","text":"public  subroutine preprocess_thom(self, b) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b","tags":"","loc":"proc/preprocess_thom.html"},{"title":"tdsops_t – x3d2","text":"public interface tdsops_t Module Procedures public  function tdsops_init (tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: tds_n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function","tags":"","loc":"interface/tdsops_t.html"},{"title":"cuda_tdsops_init – x3d2","text":"public  function cuda_tdsops_init(n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"proc/cuda_tdsops_init.html"},{"title":"cuda_tdsops_t – x3d2","text":"public interface cuda_tdsops_t Module Procedures public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"interface/cuda_tdsops_t.html"},{"title":"fft_forward_omp – x3d2","text":"public  subroutine fft_forward_omp(self, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","loc":"proc/fft_forward_omp.html"},{"title":"fft_backward_omp – x3d2","text":"public  subroutine fft_backward_omp(self, f_out) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","loc":"proc/fft_backward_omp.html"},{"title":"fft_postprocess_omp – x3d2","text":"public  subroutine fft_postprocess_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"proc/fft_postprocess_omp.html"},{"title":"omp_poisson_fft_t – x3d2","text":"public interface omp_poisson_fft_t Module Procedures private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t )","tags":"","loc":"interface/omp_poisson_fft_t.html"},{"title":"der_univ_thom – x3d2","text":"public  subroutine der_univ_thom(du, u, coeffs_s, coeffs_e, coeffs, n, thom_f, thom_s, thom_w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w","tags":"","loc":"proc/der_univ_thom.html"},{"title":"der_univ_thom_per – x3d2","text":"public  subroutine der_univ_thom_per(du, u, coeffs, n, alpha, thom_f, thom_s, thom_w, thom_p) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: thom_p","tags":"","loc":"proc/der_univ_thom_per.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/exec_dist_tds_compact.html"},{"title":"exec_dist_transeq_3fused – x3d2","text":"public  subroutine exec_dist_transeq_3fused(r_u, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, der1st, der2nd, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: der1st type( cuda_tdsops_t ), intent(in) :: der2nd real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/exec_dist_transeq_3fused.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups","tags":"","loc":"proc/exec_dist_tds_compact~2.html"},{"title":"exec_dist_transeq_compact – x3d2","text":"public  subroutine exec_dist_transeq_compact(rhs, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(out), dimension(:, :, :) :: dud real(kind=dp), intent(out), dimension(:, :, :) :: d2u real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups","tags":"","loc":"proc/exec_dist_transeq_compact.html"},{"title":"get_rdr_from_dirs – x3d2","text":"public pure function get_rdr_from_dirs(dir_from, dir_to) result(rdr_dir) Returns RDR_?2? value based on two direction inputs Arguments Type Intent Optional Attributes Name integer, intent(in) :: dir_from integer, intent(in) :: dir_to Return Value integer","tags":"","loc":"proc/get_rdr_from_dirs.html"},{"title":"get_dirs_from_rdr – x3d2","text":"public pure subroutine get_dirs_from_rdr(dir_from, dir_to, rdr_dir) Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_from integer, intent(out) :: dir_to integer, intent(in) :: rdr_dir","tags":"","loc":"proc/get_dirs_from_rdr.html"},{"title":"init – x3d2","text":"public  function init(backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in), optional :: nvars Return Value type( time_intg_t )","tags":"","loc":"proc/init~2.html"},{"title":"finalize – x3d2","text":"public  subroutine finalize(self) Type Bound time_intg_t Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self","tags":"","loc":"proc/finalize.html"},{"title":"step – x3d2","text":"public  subroutine step(self, u, v, w, du, dv, dw, dt) Type Bound time_intg_t Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self class( field_t ), intent(inout), target :: u class( field_t ), intent(inout), target :: v class( field_t ), intent(inout), target :: w class( field_t ), intent(in), target :: du class( field_t ), intent(in), target :: dv class( field_t ), intent(in), target :: dw real(kind=dp), intent(in) :: dt","tags":"","loc":"proc/step.html"},{"title":"rotate – x3d2","text":"public  subroutine rotate(sol, n) Arguments Type Intent Optional Attributes Name type( flist_t ), intent(inout) :: sol (:) integer, intent(in) :: n","tags":"","loc":"proc/rotate.html"},{"title":"time_intg_t – x3d2","text":"public interface time_intg_t Module Procedures public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in), optional :: nvars Return Value type( time_intg_t )","tags":"","loc":"interface/time_intg_t.html"},{"title":"reorder_c2x – x3d2","text":"public  subroutine reorder_c2x(u_x, u_c, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_c integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_c2x.html"},{"title":"reorder_x2c – x3d2","text":"public  subroutine reorder_x2c(u_c, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_c real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_x2c.html"},{"title":"reorder_x2y – x3d2","text":"public  subroutine reorder_x2y(u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_x2y.html"},{"title":"reorder_x2z – x3d2","text":"public  subroutine reorder_x2z(u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_x2z.html"},{"title":"reorder_y2x – x3d2","text":"public  subroutine reorder_y2x(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_y2x.html"},{"title":"reorder_y2z – x3d2","text":"public  subroutine reorder_y2z(u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_y2z.html"},{"title":"reorder_z2x – x3d2","text":"public  subroutine reorder_z2x(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_z2x.html"},{"title":"reorder_z2y – x3d2","text":"public  subroutine reorder_z2y(u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz","tags":"","loc":"proc/reorder_z2y.html"},{"title":"sum_yintox – x3d2","text":"public  subroutine sum_yintox(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz","tags":"","loc":"proc/sum_yintox.html"},{"title":"sum_zintox – x3d2","text":"public  subroutine sum_zintox(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz","tags":"","loc":"proc/sum_zintox.html"},{"title":"axpby – x3d2","text":"public  subroutine axpby(n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y","tags":"","loc":"proc/axpby.html"},{"title":"scalar_product – x3d2","text":"public  subroutine scalar_product(s, x, y, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n","tags":"","loc":"proc/scalar_product.html"},{"title":"buffer_copy – x3d2","text":"public  subroutine buffer_copy(u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo","tags":"","loc":"proc/buffer_copy.html"},{"title":"field_init – x3d2","text":"public  function field_init(ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","loc":"proc/field_init.html"},{"title":"set_data_loc – x3d2","text":"public  subroutine set_data_loc(self, data_loc) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc","tags":"","loc":"proc/set_data_loc.html"},{"title":"set_shape – x3d2","text":"public  subroutine set_shape(self, dims) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3)","tags":"","loc":"proc/set_shape.html"},{"title":"field_t – x3d2","text":"public interface field_t Module Procedures public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","loc":"interface/field_t.html"},{"title":"cuda_field_init – x3d2","text":"public  function cuda_field_init(ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","loc":"proc/cuda_field_init.html"},{"title":"cuda_allocator_init – x3d2","text":"public  function cuda_allocator_init(mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh integer, intent(in) :: sz Return Value type( cuda_allocator_t )","tags":"","loc":"proc/cuda_allocator_init.html"},{"title":"create_cuda_block – x3d2","text":"public  function create_cuda_block(self, next) result(ptr) Type Bound cuda_allocator_t Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"proc/create_cuda_block.html"},{"title":"set_shape_cuda – x3d2","text":"public  subroutine set_shape_cuda(self, dims) Type Bound cuda_field_t Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","loc":"proc/set_shape_cuda.html"},{"title":"cuda_allocator_t – x3d2","text":"public interface cuda_allocator_t Module Procedures public  function cuda_allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh integer, intent(in) :: sz Return Value type( cuda_allocator_t )","tags":"","loc":"interface/cuda_allocator_t.html"},{"title":"cuda_field_t – x3d2","text":"public interface cuda_field_t Module Procedures public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","loc":"interface/cuda_field_t.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_fields.html"},{"title":"init – x3d2","text":"public  function init(mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t )","tags":"","loc":"proc/init~3.html"},{"title":"scalar_product_omp – x3d2","text":"public  function scalar_product_omp(self, x, y) result(s) Uses m_common mpi Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp)","tags":"","loc":"proc/scalar_product_omp.html"},{"title":"alloc_omp_tdsops – x3d2","text":"public  subroutine alloc_omp_tdsops(self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/alloc_omp_tdsops.html"},{"title":"transeq_x_omp – x3d2","text":"public  subroutine transeq_x_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_x_omp.html"},{"title":"transeq_y_omp – x3d2","text":"public  subroutine transeq_y_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_y_omp.html"},{"title":"transeq_z_omp – x3d2","text":"public  subroutine transeq_z_omp(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_z_omp.html"},{"title":"transeq_omp_dist – x3d2","text":"public  subroutine transeq_omp_dist(self, du, dv, dw, u, v, w, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_omp_dist.html"},{"title":"tds_solve_omp – x3d2","text":"public  subroutine tds_solve_omp(self, du, u, dirps, tdsops) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_omp.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_dist.html"},{"title":"reorder_omp – x3d2","text":"public  subroutine reorder_omp(self, u_, u, direction) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction","tags":"","loc":"proc/reorder_omp.html"},{"title":"sum_yintox_omp – x3d2","text":"public  subroutine sum_yintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_","tags":"","loc":"proc/sum_yintox_omp.html"},{"title":"sum_zintox_omp – x3d2","text":"public  subroutine sum_zintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_","tags":"","loc":"proc/sum_zintox_omp.html"},{"title":"sum_intox_omp – x3d2","text":"public  subroutine sum_intox_omp(self, u, u_, dir_to) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ integer, intent(in) :: dir_to","tags":"","loc":"proc/sum_intox_omp.html"},{"title":"vecadd_omp – x3d2","text":"public  subroutine vecadd_omp(self, a, x, b, y) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y","tags":"","loc":"proc/vecadd_omp.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s, u_send_e, u, n, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_groups","tags":"","loc":"proc/copy_into_buffers.html"},{"title":"copy_data_to_f_omp – x3d2","text":"public  subroutine copy_data_to_f_omp(self, f, data) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data","tags":"","loc":"proc/copy_data_to_f_omp.html"},{"title":"copy_f_to_data_omp – x3d2","text":"public  subroutine copy_f_to_data_omp(self, data, f) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f","tags":"","loc":"proc/copy_f_to_data_omp.html"},{"title":"init_omp_poisson_fft – x3d2","text":"public  subroutine init_omp_poisson_fft(self, mesh, xdirps, ydirps, zdirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/init_omp_poisson_fft.html"},{"title":"omp_backend_t – x3d2","text":"public interface omp_backend_t Module Procedures public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t )","tags":"","loc":"interface/omp_backend_t.html"},{"title":"get_index_ijk – x3d2","text":"public pure subroutine get_index_ijk(i, j, k, dir_i, dir_j, dir_k, dir, SZ, nx_padded, ny_padded, nz_padded) Get cartesian index from application storage directional one Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(in) :: dir_i integer, intent(in) :: dir_j integer, intent(in) :: dir_k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded","tags":"","loc":"proc/get_index_ijk.html"},{"title":"get_index_dir – x3d2","text":"public pure subroutine get_index_dir(dir_i, dir_j, dir_k, i, j, k, dir, SZ, nx_padded, ny_padded, nz_padded) Get application storage directional index from cartesian index Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_i integer, intent(out) :: dir_j integer, intent(out) :: dir_k integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded","tags":"","loc":"proc/get_index_dir.html"},{"title":"get_index_reordering_dirs – x3d2","text":"public pure subroutine get_index_reordering_dirs(out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, mesh) Converts a set of application storage directional index to an other direction.\nThe two directions are defined by the reorder_dir variable, RDR_X2Y will go from storage in X to Y etc. Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to class( mesh_t ), intent(in) :: mesh","tags":"","loc":"proc/get_index_reordering_dirs.html"},{"title":"get_index_reordering_rdr – x3d2","text":"public pure subroutine get_index_reordering_rdr(out_i, out_j, out_k, in_i, in_j, in_k, reorder_dir, mesh) Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: reorder_dir class( mesh_t ), intent(in) :: mesh","tags":"","loc":"proc/get_index_reordering_rdr.html"},{"title":"get_index_reordering – x3d2","text":"public interface get_index_reordering Module Procedures public pure subroutine get_index_reordering_rdr (out_i, out_j, out_k, in_i, in_j, in_k, reorder_dir, mesh) Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: reorder_dir class( mesh_t ), intent(in) :: mesh public pure subroutine get_index_reordering_dirs (out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, mesh) Converts a set of application storage directional index to an other direction.\nThe two directions are defined by the reorder_dir variable, RDR_X2Y will go from storage in X to Y etc. Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to class( mesh_t ), intent(in) :: mesh","tags":"","loc":"interface/get_index_reordering.html"},{"title":"init – x3d2","text":"public  function init(backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Namelists Namelist solver_params Variables Name Type Default Description Re real(kind=dp) None dt real(kind=dp) None n_iters integer None n_output integer None poisson_solver_type character(len=3) None time_intg character(len=3) None der1st_scheme character(len=30) None der2nd_scheme character(len=30) None interpl_scheme character(len=30) None stagder_scheme character(len=30) None","tags":"","loc":"proc/init~4.html"},{"title":"allocate_tdsops – x3d2","text":"public  subroutine allocate_tdsops(dirps, backend, der1st_scheme, der2nd_scheme, interpl_scheme, stagder_scheme) Arguments Type Intent Optional Attributes Name type( dirps_t ), intent(inout) :: dirps class( base_backend_t ), intent(in) :: backend character(len=*), intent(in) :: der1st_scheme character(len=*), intent(in) :: der2nd_scheme character(len=*), intent(in) :: interpl_scheme character(len=*), intent(in) :: stagder_scheme","tags":"","loc":"proc/allocate_tdsops.html"},{"title":"transeq – x3d2","text":"public  subroutine transeq(self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/transeq.html"},{"title":"divergence_v2p – x3d2","text":"public  subroutine divergence_v2p(self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/divergence_v2p.html"},{"title":"gradient_p2v – x3d2","text":"public  subroutine gradient_p2v(self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure","tags":"","loc":"proc/gradient_p2v.html"},{"title":"curl – x3d2","text":"public  subroutine curl(self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","loc":"proc/curl.html"},{"title":"poisson_fft – x3d2","text":"public  subroutine poisson_fft(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"proc/poisson_fft.html"},{"title":"poisson_cg – x3d2","text":"public  subroutine poisson_cg(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","loc":"proc/poisson_cg.html"},{"title":"output – x3d2","text":"public  subroutine output(self, t) Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t","tags":"","loc":"proc/output.html"},{"title":"run – x3d2","text":"public  subroutine run(self) Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ), intent(inout) :: self","tags":"","loc":"proc/run.html"},{"title":"solver_t – x3d2","text":"public interface solver_t Module Procedures public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t )","tags":"","loc":"interface/solver_t.html"},{"title":"allocator_init – x3d2","text":"public  function allocator_init(mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh integer, intent(in) :: sz Return Value type( allocator_t )","tags":"","loc":"proc/allocator_init.html"},{"title":"create_block – x3d2","text":"public  function create_block(self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","loc":"proc/create_block.html"},{"title":"get_block – x3d2","text":"public  function get_block(self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Example f%data => get_block() Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer","tags":"","loc":"proc/get_block.html"},{"title":"get_block_ids – x3d2","text":"public  function get_block_ids(self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:)","tags":"","loc":"proc/get_block_ids.html"},{"title":"compute_padded_dims – x3d2","text":"public  subroutine compute_padded_dims(self, sz) Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: sz","tags":"","loc":"proc/compute_padded_dims.html"},{"title":"release_block – x3d2","text":"public  subroutine release_block(self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle","tags":"","loc":"proc/release_block.html"},{"title":"destroy – x3d2","text":"public  subroutine destroy(self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","loc":"proc/destroy.html"},{"title":"allocator_t – x3d2","text":"public interface allocator_t Module Procedures public  function allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh integer, intent(in) :: sz Return Value type( allocator_t )","tags":"","loc":"interface/allocator_t.html"},{"title":"process_spectral_div_u – x3d2","text":"public  subroutine process_spectral_div_u(div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz","tags":"","loc":"proc/process_spectral_div_u.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf","tags":"","loc":"proc/der_univ_dist.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc","tags":"","loc":"proc/der_univ_subs.html"},{"title":"init – x3d2","text":"public  function init(mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t )","tags":"","loc":"proc/init~5.html"},{"title":"scalar_product_cuda – x3d2","text":"public  function scalar_product_cuda(self, x, y) result(s) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp)","tags":"","loc":"proc/scalar_product_cuda.html"},{"title":"alloc_cuda_tdsops – x3d2","text":"public  subroutine alloc_cuda_tdsops(self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","loc":"proc/alloc_cuda_tdsops.html"},{"title":"transeq_x_cuda – x3d2","text":"public  subroutine transeq_x_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_x_cuda.html"},{"title":"transeq_y_cuda – x3d2","text":"public  subroutine transeq_y_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_y_cuda.html"},{"title":"transeq_z_cuda – x3d2","text":"public  subroutine transeq_z_cuda(self, du, dv, dw, u, v, w, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_z_cuda.html"},{"title":"transeq_cuda_dist – x3d2","text":"public  subroutine transeq_cuda_dist(self, du, dv, dw, u, v, w, dirps, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/transeq_cuda_dist.html"},{"title":"transeq_cuda_thom – x3d2","text":"public  subroutine transeq_cuda_thom(self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","loc":"proc/transeq_cuda_thom.html"},{"title":"tds_solve_cuda – x3d2","text":"public  subroutine tds_solve_cuda(self, du, u, dirps, tdsops) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops","tags":"","loc":"proc/tds_solve_cuda.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, dirps, tdsops, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/tds_solve_dist~2.html"},{"title":"reorder_cuda – x3d2","text":"public  subroutine reorder_cuda(self, u_o, u_i, direction) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction","tags":"","loc":"proc/reorder_cuda.html"},{"title":"sum_yintox_cuda – x3d2","text":"public  subroutine sum_yintox_cuda(self, u, u_y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y","tags":"","loc":"proc/sum_yintox_cuda.html"},{"title":"sum_zintox_cuda – x3d2","text":"public  subroutine sum_zintox_cuda(self, u, u_z) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z","tags":"","loc":"proc/sum_zintox_cuda.html"},{"title":"vecadd_cuda – x3d2","text":"public  subroutine vecadd_cuda(self, a, x, b, y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y","tags":"","loc":"proc/vecadd_cuda.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n","tags":"","loc":"proc/copy_into_buffers~2.html"},{"title":"copy_data_to_f_cuda – x3d2","text":"public  subroutine copy_data_to_f_cuda(self, f, data) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data","tags":"","loc":"proc/copy_data_to_f_cuda.html"},{"title":"copy_f_to_data_cuda – x3d2","text":"public  subroutine copy_f_to_data_cuda(self, data, f) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f","tags":"","loc":"proc/copy_f_to_data_cuda.html"},{"title":"init_cuda_poisson_fft – x3d2","text":"public  subroutine init_cuda_poisson_fft(self, mesh, xdirps, ydirps, zdirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"proc/init_cuda_poisson_fft.html"},{"title":"resolve_field_t – x3d2","text":"public  subroutine resolve_field_t(u_dev, u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, pointer, dimension(:, :, :) :: u_dev class( field_t ), intent(in) :: u","tags":"","loc":"proc/resolve_field_t.html"},{"title":"cuda_backend_t – x3d2","text":"public interface cuda_backend_t Module Procedures public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t )","tags":"","loc":"interface/cuda_backend_t.html"},{"title":"base_init – x3d2","text":"public  subroutine base_init(self) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self","tags":"","loc":"proc/base_init~2.html"},{"title":"get_field_data – x3d2","text":"public  subroutine get_field_data(self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian)","tags":"","loc":"proc/get_field_data.html"},{"title":"set_field_data – x3d2","text":"public  subroutine set_field_data(self, f, data, dir) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian)","tags":"","loc":"proc/set_field_data.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_fields~2.html"},{"title":"sendrecv_3fields – x3d2","text":"public  subroutine sendrecv_3fields(f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"proc/sendrecv_3fields.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf","tags":"","loc":"proc/der_univ_dist~2.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc","tags":"","loc":"proc/der_univ_subs~2.html"},{"title":"transeq_3fused_dist – x3d2","text":"public  subroutine transeq_3fused_dist(du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n, d1_coeffs_s, d1_coeffs_e, d1_coeffs, d1_fw, d1_bw, d1_af, d2_coeffs_s, d2_coeffs_e, d2_coeffs, d2_fw, d2_bw, d2_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n real(kind=dp), intent(in), device :: d1_coeffs_s (:,:) real(kind=dp), intent(in), device :: d1_coeffs_e (:,:) real(kind=dp), intent(in), device :: d1_coeffs (:) real(kind=dp), intent(in), device :: d1_fw (:) real(kind=dp), intent(in), device :: d1_bw (:) real(kind=dp), intent(in), device :: d1_af (:) real(kind=dp), intent(in), device :: d2_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2_coeffs (:) real(kind=dp), intent(in), device :: d2_fw (:) real(kind=dp), intent(in), device :: d2_bw (:) real(kind=dp), intent(in), device :: d2_af (:)","tags":"","loc":"proc/transeq_3fused_dist.html"},{"title":"transeq_3fused_subs – x3d2","text":"public  subroutine transeq_3fused_subs(r_u, conv, du, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, d1_sa, d1_sc, d2_sa, d2_sc, n, nu) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e real(kind=dp), intent(in), device, dimension(:) :: d1_sa real(kind=dp), intent(in), device, dimension(:) :: d1_sc real(kind=dp), intent(in), device, dimension(:) :: d2_sa real(kind=dp), intent(in), device, dimension(:) :: d2_sc integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu","tags":"","loc":"proc/transeq_3fused_subs.html"},{"title":"exec_thom_tds_compact – x3d2","text":"public  subroutine exec_thom_tds_compact(du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u type( cuda_tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"proc/exec_thom_tds_compact.html"},{"title":"fft_forward_cuda – x3d2","text":"public  subroutine fft_forward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f","tags":"","loc":"proc/fft_forward_cuda.html"},{"title":"fft_backward_cuda – x3d2","text":"public  subroutine fft_backward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f","tags":"","loc":"proc/fft_backward_cuda.html"},{"title":"fft_postprocess_cuda – x3d2","text":"public  subroutine fft_postprocess_cuda(self) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"proc/fft_postprocess_cuda.html"},{"title":"cuda_poisson_fft_t – x3d2","text":"public interface cuda_poisson_fft_t Module Procedures private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t )","tags":"","loc":"interface/cuda_poisson_fft_t.html"},{"title":"mesh_init – x3d2","text":"public  function mesh_init(dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z Return Value type( mesh_t )","tags":"","loc":"proc/mesh_init.html"},{"title":"get_sz – x3d2","text":"public pure function get_sz(self) result(sz) Getter for parameter SZ Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/get_sz.html"},{"title":"get_dims – x3d2","text":"public pure function get_dims(self, data_loc) result(dims) Getter for local domain dimensions Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3)","tags":"","loc":"proc/get_dims.html"},{"title":"get_global_dims – x3d2","text":"public pure function get_global_dims(self, data_loc) result(dims) Getter for local domain dimensions Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3)","tags":"","loc":"proc/get_global_dims.html"},{"title":"get_dims_dataloc – x3d2","text":"public pure function get_dims_dataloc(data_loc, vert_dims, cell_dims) result(dims) Getter for domain dimensions Arguments Type Intent Optional Attributes Name integer, intent(in) :: data_loc integer, intent(in), dimension(3) :: vert_dims integer, intent(in), dimension(3) :: cell_dims Return Value integer, dimension(3)","tags":"","loc":"proc/get_dims_dataloc.html"},{"title":"get_padded_dims_dir – x3d2","text":"public pure function get_padded_dims_dir(self, dir) result(dims_padded) Getter for padded dimensions with structure in dir direction Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer, dimension(3)","tags":"","loc":"proc/get_padded_dims_dir.html"},{"title":"get_padded_dims_phi – x3d2","text":"public pure function get_padded_dims_phi(self, phi) result(dims_padded) Getter for padded dimensions for field phi\nGets the field direction from the field itself Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3)","tags":"","loc":"proc/get_padded_dims_phi.html"},{"title":"get_n_groups_dir – x3d2","text":"public pure function get_n_groups_dir(self, dir) result(n_groups) Getter for the number of groups for fields in direction dir Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer","tags":"","loc":"proc/get_n_groups_dir.html"},{"title":"get_n_groups_phi – x3d2","text":"public pure function get_n_groups_phi(self, phi) result(n_groups) Getter for the number of groups for fields phi Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer","tags":"","loc":"proc/get_n_groups_phi.html"},{"title":"get_field_dims_phi – x3d2","text":"public pure function get_field_dims_phi(self, phi) result(dims) Getter for the dimensions of field phi Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3)","tags":"","loc":"proc/get_field_dims_phi.html"},{"title":"get_field_dims_phi_dataloc – x3d2","text":"public pure function get_field_dims_phi_dataloc(self, phi, data_loc) result(dims) Getter for the dimensions of field phi where data is located on data_loc Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi integer, intent(in) :: data_loc Return Value integer, dimension(3)","tags":"","loc":"proc/get_field_dims_phi_dataloc.html"},{"title":"get_field_dims_dir – x3d2","text":"public pure function get_field_dims_dir(self, dir, data_loc) result(dims) Getter for the dimensions of an array directed along dir where data would be located on data_loc Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer, dimension(3)","tags":"","loc":"proc/get_field_dims_dir.html"},{"title":"get_n_phi – x3d2","text":"public pure function get_n_phi(self, phi) result(n) Getter for the main dimension of field phi Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer","tags":"","loc":"proc/get_n_phi.html"},{"title":"get_n_dir – x3d2","text":"public pure function get_n_dir(self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer","tags":"","loc":"proc/get_n_dir.html"},{"title":"get_coordinates – x3d2","text":"public pure function get_coordinates(self, i, j, k) result(xloc) Get the physical location of a cell center with i,j,k local indices Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp), dimension(3)","tags":"","loc":"proc/get_coordinates.html"},{"title":"is_root – x3d2","text":"public pure function is_root(self) result(is_root_rank) Returns whether or not the current rank is the root rank Type Bound parallel_t Arguments Type Intent Optional Attributes Name class( parallel_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/is_root.html"},{"title":"set_padded_dims – x3d2","text":"public  subroutine set_padded_dims(self, vert_dims) Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in), dimension(3) :: vert_dims","tags":"","loc":"proc/set_padded_dims.html"},{"title":"set_sz – x3d2","text":"public  subroutine set_sz(self, sz) Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in) :: sz","tags":"","loc":"proc/set_sz.html"},{"title":"domain_decomposition – x3d2","text":"public  subroutine domain_decomposition(mesh) Supports 1D, 2D, and 3D domain decomposition. Current implementation allows only constant sub-domain size across a\ngiven direction. Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh","tags":"","loc":"proc/domain_decomposition.html"},{"title":"mesh_t – x3d2","text":"public interface mesh_t Module Procedures public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z Return Value type( mesh_t )","tags":"","loc":"interface/mesh_t.html"},{"title":"m_poisson_fft – x3d2","text":"Uses m_allocator m_tdsops m_common m_mesh Abstract Interfaces abstract interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in abstract interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out abstract interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self Derived Types type, public, abstract :: poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward procedure( fft_backward ), public, deferred :: fft_backward procedure( fft_postprocess ), public, deferred :: fft_postprocess procedure, public :: base_init procedure, public :: waves_set Subroutines public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"module/m_poisson_fft.html"},{"title":"m_tdsops – x3d2","text":"Uses iso_fortran_env m_common m_mesh Interfaces public        interface tdsops_t public  function tdsops_init (tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n', 'delta', 'operation', and 'scheme' are necessary arguments.\nNumber of points 'n', distance between two points 'delta', the\n'operation' the tridiagonal system defines, and the 'scheme' that\nspecifies the exact scheme we choose to apply for the operation.\nThe remaining arguments are optional.\n'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are either 'null' or not defined.\n'sym' is relevant when the boundary condition is free-slip. If sym is\n.true. then it means the field we operate on is assumed to be an even\nfunction (symmetric) accross the boundary. If it is .false. it means\nthat the field is assumed to be an odd function (anti-symmetric).\n'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: tds_n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Derived Types type, public :: tdsops_t Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp logical, public :: periodic integer, public :: tds_n integer, public :: dir integer, public :: n_halo Constructor public\n\n                    \n                    function tdsops_init (tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Constructor function for the tdsops_t class. Read more… Type-Bound Procedures procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st procedure, public :: preprocess_thom procedure, public :: preprocess_dist type, public :: dirps_t Directional tridiagonal solver container. Read more… Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: dir Functions public  function tdsops_init (tds_n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: tds_n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' character(len=*), intent(in), optional :: bc_start Boundary Cond. character(len=*), intent(in), optional :: bc_end Boundary Cond. logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function public pure function get_tds_n (mesh, dir, from_to) result(tds_n) Get the tds_n size based on the from_to value (and the mesh) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh integer, intent(in) :: dir character(len=*), intent(in), optional :: from_to Return Value integer Subroutines public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b","tags":"","loc":"module/m_tdsops.html"},{"title":"m_cuda_tdsops – x3d2","text":"Uses iso_fortran_env m_tdsops m_common Interfaces public        interface cuda_tdsops_t public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Derived Types type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha real(kind=dp), public :: a real(kind=dp), public :: b real(kind=dp), public :: c = 0._dp real(kind=dp), public :: d = 0._dp logical, public :: periodic integer, public :: tds_n integer, public :: dir integer, public :: n_halo real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: thom_f_dev (:) real(kind=dp), public, device, allocatable :: thom_s_dev (:) real(kind=dp), public, device, allocatable :: thom_w_dev (:) real(kind=dp), public, device, allocatable :: thom_p_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public\n\n                    \n                    function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Type-Bound Procedures procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st procedure, public :: preprocess_thom procedure, public :: preprocess_dist Functions public  function cuda_tdsops_init (n, delta, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","loc":"module/m_cuda_tdsops.html"},{"title":"m_omp_poisson_fft – x3d2","text":"Uses m_allocator m_tdsops m_common m_poisson_fft m_mesh Interfaces public        interface omp_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps Return Value type( omp_poisson_fft_t ) Derived Types type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver\nIt can only handle 1D decompositions along z direction. Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor private\n\n                    \n                    function init (mesh, xdirps, ydirps, zdirps) Type-Bound Procedures procedure, public :: base_init procedure, public :: waves_set procedure, public :: fft_forward => fft_forward_omp procedure, public :: fft_backward => fft_backward_omp procedure, public :: fft_postprocess => fft_postprocess_omp Subroutines public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_postprocess_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","loc":"module/m_omp_poisson_fft.html"},{"title":"m_cuda_kernels_thom – x3d2","text":"Uses m_common cudafor Subroutines public  subroutine der_univ_thom (du, u, coeffs_s, coeffs_e, coeffs, n, thom_f, thom_s, thom_w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w public  subroutine der_univ_thom_per (du, u, coeffs, n, alpha, thom_f, thom_s, thom_w, thom_p) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: thom_p","tags":"","loc":"module/m_cuda_kernels_thom.html"},{"title":"m_cuda_exec_dist – x3d2","text":"Uses m_cuda_tdsops cudafor m_cuda_kernels_dist m_cuda_common m_cuda_sendrecv mpi m_common Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine exec_dist_transeq_3fused (r_u, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, der1st, der2nd, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: der1st type( cuda_tdsops_t ), intent(in) :: der2nd real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"module/m_cuda_exec_dist.html"},{"title":"m_cuda_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 32","tags":"","loc":"module/m_cuda_common.html"},{"title":"m_omp_exec_dist – x3d2","text":"Uses m_omp_sendrecv m_omp_kernels_dist m_tdsops m_omp_common mpi m_common Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups public  subroutine exec_dist_transeq_compact (rhs, du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(out), dimension(:, :, :) :: dud real(kind=dp), intent(out), dimension(:, :, :) :: d2u real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups","tags":"","loc":"module/m_omp_exec_dist.html"},{"title":"m_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(0.0d0) real(kind=dp), public, parameter :: pi = 4*atan(1.0_dp) integer, public, parameter :: RDR_X2Y = 12 integer, public, parameter :: RDR_X2Z = 13 integer, public, parameter :: RDR_Y2X = 21 integer, public, parameter :: RDR_Y2Z = 23 integer, public, parameter :: RDR_Z2X = 31 integer, public, parameter :: RDR_Z2Y = 32 integer, public, parameter :: RDR_C2X = 41 integer, public, parameter :: RDR_C2Y = 42 integer, public, parameter :: RDR_C2Z = 43 integer, public, parameter :: RDR_X2C = 14 integer, public, parameter :: RDR_Y2C = 24 integer, public, parameter :: RDR_Z2C = 34 integer, public, parameter :: DIR_X = 1 integer, public, parameter :: DIR_Y = 2 integer, public, parameter :: DIR_Z = 3 integer, public, parameter :: DIR_C = 4 integer, public, parameter :: POISSON_SOLVER_FFT = 0 integer, public, parameter :: POISSON_SOLVER_CG = 1 integer, public, parameter :: VERT = 1 integer, public, parameter :: CELL = 2 integer, public, parameter :: X_FACE = 11 integer, public, parameter :: Y_FACE = 12 integer, public, parameter :: Z_FACE = 13 integer, public, parameter :: X_EDGE = 101 integer, public, parameter :: Y_EDGE = 102 integer, public, parameter :: Z_EDGE = 103 integer, public, parameter :: none = -1 integer, public, parameter :: BC_PERIODIC = 0 integer, public, parameter :: BC_NEUMANN = 1 integer, public, parameter :: BC_DIRICHLET = 2 integer, protected :: rdr_map (4,4) = reshape([0, RDR_Y2X, RDR_Z2X, RDR_C2X, RDR_X2Y, 0, RDR_Z2Y, RDR_C2Y, RDR_X2Z, RDR_Y2Z, 0, RDR_C2Z, RDR_X2C, RDR_Y2C, RDR_Z2C, 0], shape=[4, 4]) Functions public pure function get_rdr_from_dirs (dir_from, dir_to) result(rdr_dir) Returns RDR_?2? value based on two direction inputs Arguments Type Intent Optional Attributes Name integer, intent(in) :: dir_from integer, intent(in) :: dir_to Return Value integer Subroutines public pure subroutine get_dirs_from_rdr (dir_from, dir_to, rdr_dir) Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_from integer, intent(out) :: dir_to integer, intent(in) :: rdr_dir","tags":"","loc":"module/m_common.html"},{"title":"m_omp_common – x3d2","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 16","tags":"","loc":"module/m_omp_common.html"},{"title":"m_time_integrator – x3d2","text":"Uses m_allocator m_common m_base_backend Interfaces public        interface time_intg_t public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Abstract Interfaces abstract interface public  subroutine stepper_func(self, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self real(kind=dp), intent(in) :: dt Derived Types type, public :: time_intg_t Components Type Visibility Attributes Name Initial integer, public :: method integer, public :: istep integer, public :: istage integer, public :: order integer, public :: nstep integer, public :: nstage integer, public :: nvars integer, public :: nolds real(kind=dp), public :: coeffs (4,4) real(kind=dp), public :: rk_b (4,4) real(kind=dp), public :: rk_a (3,3,4) character(len=3), public :: sname type( flist_t ), public, allocatable :: olds (:,:) type( flist_t ), public, allocatable :: curr (:) type( flist_t ), public, allocatable :: deriv (:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator procedure( stepper_func ), public, pointer :: stepper => null() Constructor public\n\n                    \n                    function init (backend, allocator, method, nvars) Type-Bound Procedures procedure, public :: finalize procedure, public :: step procedure, public :: runge_kutta procedure, public :: adams_bashforth Functions public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in), optional :: nvars Return Value type( time_intg_t ) Subroutines public  subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self public  subroutine step (self, u, v, w, du, dv, dw, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self class( field_t ), intent(inout), target :: u class( field_t ), intent(inout), target :: v class( field_t ), intent(inout), target :: w class( field_t ), intent(in), target :: du class( field_t ), intent(in), target :: dv class( field_t ), intent(in), target :: dw real(kind=dp), intent(in) :: dt public  subroutine rotate (sol, n) Arguments Type Intent Optional Attributes Name type( flist_t ), intent(inout) :: sol (:) integer, intent(in) :: n","tags":"","loc":"module/m_time_integrator.html"},{"title":"m_cuda_kernels_reorder – x3d2","text":"Uses m_cuda_common m_common cudafor Subroutines public  subroutine reorder_c2x (u_x, u_c, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_c integer, intent(in), value :: nz public  subroutine reorder_x2c (u_c, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_c real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_x2y (u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_x2z (u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_y2x (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine reorder_y2z (u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine reorder_z2x (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz public  subroutine reorder_z2y (u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine sum_yintox (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine sum_zintox (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz public  subroutine axpby (n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y public  subroutine scalar_product (s, x, y, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n public  subroutine buffer_copy (u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo","tags":"","loc":"module/m_cuda_kernels_reorder.html"},{"title":"m_field – x3d2","text":"Uses m_common Interfaces public        interface field_t public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Derived Types type, public :: field_t Memory block type holding both a data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public\n\n                    \n                    function field_init (ngrid, next, id) Type-Bound Procedures procedure, public :: set_shape procedure, public :: set_data_loc Functions public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Subroutines public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc public  subroutine set_shape (self, dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3)","tags":"","loc":"module/m_field.html"},{"title":"m_cuda_allocator – x3d2","text":"Uses m_allocator m_field m_common m_mesh Interfaces public        interface cuda_allocator_t public  function cuda_allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh integer, intent(in) :: sz Return Value type( cuda_allocator_t ) public        interface cuda_field_t public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Derived Types type, public, extends( allocator_t ) :: cuda_allocator_t Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( mesh_t ), public, pointer :: mesh The pointer to the first block on the list.  Non associated if\nthe list is empty class( field_t ), public, pointer :: first => null() Constructor public\n\n                    \n                    function cuda_allocator_init (mesh, sz) Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: get_block_ids procedure, public :: destroy procedure, public :: compute_padded_dims procedure, public :: create_block => create_cuda_block type, public, extends( field_t ) :: cuda_field_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, device, pointer, contiguous :: data_d (:,:,:) Constructor public\n\n                    \n                    function cuda_field_init (ngrid, next, id) Type-Bound Procedures procedure, public :: set_data_loc procedure, public :: set_shape => set_shape_cuda Functions public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) public  function cuda_allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh integer, intent(in) :: sz Return Value type( cuda_allocator_t ) public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer Subroutines public  subroutine set_shape_cuda (self, dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","loc":"module/m_cuda_allocator.html"},{"title":"m_omp_sendrecv – x3d2","text":"Uses m_common mpi Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"module/m_omp_sendrecv.html"},{"title":"m_omp_backend – x3d2","text":"Uses m_allocator m_omp_sendrecv m_omp_poisson_fft m_base_backend m_ordering m_omp_exec_dist m_tdsops m_omp_common m_common m_mesh Interfaces public        interface omp_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Derived Types type, public, extends( base_backend_t ) :: omp_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public\n\n                    \n                    function init (mesh, allocator) Type-Bound Procedures procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data procedure, public :: alloc_tdsops => alloc_omp_tdsops procedure, public :: transeq_x => transeq_x_omp procedure, public :: transeq_y => transeq_y_omp procedure, public :: transeq_z => transeq_z_omp procedure, public :: tds_solve => tds_solve_omp procedure, public :: reorder => reorder_omp procedure, public :: sum_yintox => sum_yintox_omp procedure, public :: sum_zintox => sum_zintox_omp procedure, public :: vecadd => vecadd_omp procedure, public :: scalar_product => scalar_product_omp procedure, public :: copy_data_to_f => copy_data_to_f_omp procedure, public :: copy_f_to_data => copy_f_to_data_omp procedure, public :: init_poisson_fft => init_omp_poisson_fft procedure, public :: transeq_omp_dist Functions public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) public  function scalar_product_omp (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Subroutines public  subroutine alloc_omp_tdsops (self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_omp (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine sum_intox_omp (self, u, u_, dir_to) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ integer, intent(in) :: dir_to public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine copy_into_buffers (u_send_s, u_send_e, u, n, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_groups public  subroutine copy_data_to_f_omp (self, f, data) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data public  subroutine copy_f_to_data_omp (self, data, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f public  subroutine init_omp_poisson_fft (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps","tags":"","loc":"module/m_omp_backend.html"},{"title":"m_ordering – x3d2","text":"\"Application storage\" stores spatial data with a directionality for better cache locality\n This set of functions converts indices from this application storage (_dir) to cartesian indices (_ijk) Uses m_common m_mesh Interfaces public        interface get_index_reordering public pure subroutine get_index_reordering_rdr (out_i, out_j, out_k, in_i, in_j, in_k, reorder_dir, mesh) Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: reorder_dir class( mesh_t ), intent(in) :: mesh public pure subroutine get_index_reordering_dirs (out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, mesh) Converts a set of application storage directional index to an other direction.\nThe two directions are defined by the reorder_dir variable, RDR_X2Y will go from storage in X to Y etc. Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to class( mesh_t ), intent(in) :: mesh Subroutines public pure subroutine get_index_ijk (i, j, k, dir_i, dir_j, dir_k, dir, SZ, nx_padded, ny_padded, nz_padded) Get cartesian index from application storage directional one Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(in) :: dir_i integer, intent(in) :: dir_j integer, intent(in) :: dir_k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded public pure subroutine get_index_dir (dir_i, dir_j, dir_k, i, j, k, dir, SZ, nx_padded, ny_padded, nz_padded) Get application storage directional index from cartesian index Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_i integer, intent(out) :: dir_j integer, intent(out) :: dir_k integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded public pure subroutine get_index_reordering_dirs (out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, mesh) Converts a set of application storage directional index to an other direction.\nThe two directions are defined by the reorder_dir variable, RDR_X2Y will go from storage in X to Y etc. Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to class( mesh_t ), intent(in) :: mesh public pure subroutine get_index_reordering_rdr (out_i, out_j, out_k, in_i, in_j, in_k, reorder_dir, mesh) Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: reorder_dir class( mesh_t ), intent(in) :: mesh","tags":"","loc":"module/m_ordering.html"},{"title":"m_solver – x3d2","text":"Uses m_allocator m_base_backend m_time_integrator iso_fortran_env m_tdsops mpi m_common m_mesh Interfaces public        interface solver_t public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Abstract Interfaces abstract interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u Derived Types type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu integer, public :: n_iters integer, public :: n_output integer, public :: ngrid class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w class( base_backend_t ), public, pointer :: backend class( mesh_t ), public, pointer :: mesh type( time_intg_t ), public :: time_integrator type( allocator_t ), public, pointer :: host_allocator type( dirps_t ), public, pointer :: xdirps type( dirps_t ), public, pointer :: ydirps type( dirps_t ), public, pointer :: zdirps procedure( poisson_solver ), public, pointer :: poisson => null() Constructor public\n\n                    \n                    function init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: transeq procedure, public :: divergence_v2p procedure, public :: gradient_p2v procedure, public :: curl procedure, public :: output procedure, public :: run Functions public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Subroutines public  subroutine allocate_tdsops (dirps, backend, der1st_scheme, der2nd_scheme, interpl_scheme, stagder_scheme) Arguments Type Intent Optional Attributes Name type( dirps_t ), intent(inout) :: dirps class( base_backend_t ), intent(in) :: backend character(len=*), intent(in) :: der1st_scheme character(len=*), intent(in) :: der2nd_scheme character(len=*), intent(in) :: interpl_scheme character(len=*), intent(in) :: stagder_scheme public  subroutine transeq (self, du, dv, dw, u, v, w) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine divergence_v2p (self, div_u, u, v, w) Divergence of a vector field (u, v, w).\nInputs from velocity grid and outputs to pressure grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Gradient of a scalar field 'pressure'.\nInputs from pressure grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Curl of a vector field (u, v, w).\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine poisson_fft (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine poisson_cg (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine output (self, t) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: self real(kind=dp), intent(in) :: t public  subroutine run (self) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(inout) :: self","tags":"","loc":"module/m_solver.html"},{"title":"m_allocator – x3d2","text":"Uses iso_fortran_env m_field m_common m_mesh Interfaces public        interface allocator_t public  function allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh integer, intent(in) :: sz Return Value type( allocator_t ) Derived Types type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size m_allocator objects: Read more… Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( mesh_t ), public, pointer :: mesh The pointer to the first block on the list.  Non associated if\nthe list is empty class( field_t ), public, pointer :: first => null() Constructor public\n\n                    \n                    function allocator_init (mesh, sz) Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: create_block procedure, public :: get_block_ids procedure, public :: destroy procedure, public :: compute_padded_dims type, public :: flist_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr Functions public  function allocator_init (mesh, sz) result(allocator) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh integer, intent(in) :: sz Return Value type( allocator_t ) public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self type( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) Subroutines public  subroutine compute_padded_dims (self, sz) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: sz public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","loc":"module/m_allocator.html"},{"title":"m_cuda_spectral – x3d2","text":"Uses m_common cudafor Subroutines public  subroutine process_spectral_div_u (div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz","tags":"","loc":"module/m_cuda_spectral.html"},{"title":"m_omp_kernels_dist – x3d2","text":"Uses m_omp_common omp_lib m_common Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc","tags":"","loc":"module/m_omp_kernels_dist.html"},{"title":"m_cuda_backend – x3d2","text":"Uses m_allocator m_cuda_exec_dist m_cuda_tdsops cudafor m_base_backend iso_fortran_env m_cuda_poisson_fft m_cuda_allocator m_cuda_kernels_dist m_cuda_common m_tdsops m_cuda_sendrecv mpi m_cuda_kernels_reorder m_common m_poisson_fft m_mesh Interfaces public        interface cuda_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Derived Types type, public, extends( base_backend_t ) :: cuda_backend_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft integer, public :: MPI_FP_PREC = dp real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public\n\n                    \n                    function init (mesh, allocator) Type-Bound Procedures procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data procedure, public :: alloc_tdsops => alloc_cuda_tdsops procedure, public :: transeq_x => transeq_x_cuda procedure, public :: transeq_y => transeq_y_cuda procedure, public :: transeq_z => transeq_z_cuda procedure, public :: tds_solve => tds_solve_cuda procedure, public :: reorder => reorder_cuda procedure, public :: sum_yintox => sum_yintox_cuda procedure, public :: sum_zintox => sum_zintox_cuda procedure, public :: vecadd => vecadd_cuda procedure, public :: scalar_product => scalar_product_cuda procedure, public :: copy_data_to_f => copy_data_to_f_cuda procedure, public :: copy_f_to_data => copy_f_to_data_cuda procedure, public :: init_poisson_fft => init_cuda_poisson_fft procedure, public :: transeq_cuda_dist procedure, public :: transeq_cuda_thom procedure, public :: tds_solve_dist Functions public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) public  function scalar_product_cuda (self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Subroutines public  subroutine alloc_cuda_tdsops (self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_cuda (self, du, u, dirps, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, dirps, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine copy_into_buffers (u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n public  subroutine copy_data_to_f_cuda (self, f, data) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data public  subroutine copy_f_to_data_cuda (self, data, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f public  subroutine init_cuda_poisson_fft (self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps public  subroutine resolve_field_t (u_dev, u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, pointer, dimension(:, :, :) :: u_dev class( field_t ), intent(in) :: u","tags":"","loc":"module/m_cuda_backend.html"},{"title":"m_base_backend – x3d2","text":"Uses m_allocator m_tdsops mpi m_common m_poisson_fft m_mesh Abstract Interfaces abstract interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, dirps) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps abstract interface public  subroutine tds_solve(self, du, u, dirps, tdsops) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u type( dirps_t ), intent(in) :: dirps class( tdsops_t ), intent(in) :: tdsops abstract interface public  subroutine reorder(self, u_, u, direction) reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction abstract interface public  subroutine sum_intox(self, u, u_) sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ abstract interface public  subroutine vecadd(self, a, x, b, y) adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y abstract interface public  function scalar_product(self, x, y) result(s) Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) abstract interface public  subroutine copy_data_to_f(self, f, data) Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory. Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data abstract interface public  subroutine copy_f_to_data(self, data, f) Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f abstract interface public  subroutine alloc_tdsops(self, tdsops, dir, operation, scheme, n_halo, from_to, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: dir character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to character(len=*), intent(in), optional :: bc_start character(len=*), intent(in), optional :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu abstract interface public  subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Derived Types type, public, abstract :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public :: nu class( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x procedure( transeq_ders ), public, deferred :: transeq_y procedure( transeq_ders ), public, deferred :: transeq_z procedure( tds_solve ), public, deferred :: tds_solve procedure( reorder ), public, deferred :: reorder procedure( sum_intox ), public, deferred :: sum_yintox procedure( sum_intox ), public, deferred :: sum_zintox procedure( vecadd ), public, deferred :: vecadd procedure( scalar_product ), public, deferred :: scalar_product procedure( copy_data_to_f ), public, deferred :: copy_data_to_f procedure( copy_f_to_data ), public, deferred :: copy_f_to_data procedure( alloc_tdsops ), public, deferred :: alloc_tdsops procedure( init_poisson_fft ), public, deferred :: init_poisson_fft procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data Subroutines public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian)","tags":"","loc":"module/m_base_backend.html"},{"title":"m_cuda_sendrecv – x3d2","text":"Uses mpi m_common cudafor Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next public  subroutine sendrecv_3fields (f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","loc":"module/m_cuda_sendrecv.html"},{"title":"m_cuda_kernels_dist – x3d2","text":"Uses m_common cudafor Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, coeffs_s, coeffs_e, coeffs, n, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc public  subroutine transeq_3fused_dist (du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n, d1_coeffs_s, d1_coeffs_e, d1_coeffs, d1_fw, d1_bw, d1_af, d2_coeffs_s, d2_coeffs_e, d2_coeffs, d2_fw, d2_bw, d2_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n real(kind=dp), intent(in), device :: d1_coeffs_s (:,:) real(kind=dp), intent(in), device :: d1_coeffs_e (:,:) real(kind=dp), intent(in), device :: d1_coeffs (:) real(kind=dp), intent(in), device :: d1_fw (:) real(kind=dp), intent(in), device :: d1_bw (:) real(kind=dp), intent(in), device :: d1_af (:) real(kind=dp), intent(in), device :: d2_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2_coeffs (:) real(kind=dp), intent(in), device :: d2_fw (:) real(kind=dp), intent(in), device :: d2_bw (:) real(kind=dp), intent(in), device :: d2_af (:) public  subroutine transeq_3fused_subs (r_u, conv, du, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, d1_sa, d1_sc, d2_sa, d2_sc, n, nu) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_u real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e real(kind=dp), intent(in), device, dimension(:) :: d1_sa real(kind=dp), intent(in), device, dimension(:) :: d1_sc real(kind=dp), intent(in), device, dimension(:) :: d2_sa real(kind=dp), intent(in), device, dimension(:) :: d2_sc integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu","tags":"","loc":"module/m_cuda_kernels_dist.html"},{"title":"m_cuda_exec_thom – x3d2","text":"Uses m_cuda_tdsops m_common cudafor m_cuda_kernels_thom Subroutines public  subroutine exec_thom_tds_compact (du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u type( cuda_tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","loc":"module/m_cuda_exec_thom.html"},{"title":"m_cuda_poisson_fft – x3d2","text":"Uses m_allocator cudafor iso_fortran_env cufftXt m_cuda_allocator m_tdsops m_cuda_spectral mpi iso_c_binding cufft m_common m_poisson_fft m_mesh Interfaces public        interface cuda_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps) result(poisson_fft) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Return Value type( cuda_poisson_fft_t ) Derived Types type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y direction in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants complex(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: by_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: az_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev Wave numbers in x, y, and z integer, public :: plan3D_fw Forward and backward FFT transform plans integer, public :: plan3D_bw Forward and backward FFT transform plans type(cudaLibXtDesc), public, pointer :: xtdesc cuFFTMp object manages decomposition and data storage Constructor private\n\n                    \n                    function init (mesh, xdirps, ydirps, zdirps) Type-Bound Procedures procedure, public :: base_init procedure, public :: waves_set procedure, public :: fft_forward => fft_forward_cuda procedure, public :: fft_backward => fft_backward_cuda procedure, public :: fft_postprocess => fft_postprocess_cuda Subroutines public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f public  subroutine fft_postprocess_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self","tags":"","loc":"module/m_cuda_poisson_fft.html"},{"title":"m_mesh – x3d2","text":"Uses iso_fortran_env m_field m_common mpi Interfaces public        interface mesh_t public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z Return Value type( mesh_t ) Derived Types type, public :: geo_t Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(3) :: d real(kind=dp), public, dimension(3) :: L type, public :: parallel_t Components Type Visibility Attributes Name Initial integer, public :: nrank integer, public :: nproc integer, public, dimension(3) :: nrank_dir integer, public, dimension(3) :: nproc_dir integer, public, dimension(3) :: n_offset integer, public, dimension(3) :: pnext integer, public, dimension(3) :: pprev Type-Bound Procedures procedure, public :: is_root type, public :: mesh_t Components Type Visibility Attributes Name Initial type( geo_t ), public, allocatable :: geo type( parallel_t ), public, allocatable :: par Constructor public\n\n                    \n                    function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Type-Bound Procedures procedure, public :: get_SZ => get_sz procedure, public :: get_dims procedure, public :: get_global_dims procedure, public :: get_n_groups_dir procedure, public :: get_n_groups_phi generic, public :: get_n_groups => get_n_groups_dir , get_n_groups_phi procedure, public :: get_field_dims_dir procedure, public :: get_field_dims_phi procedure, public :: get_field_dims_phi_dataloc generic, public :: get_field_dims => get_field_dims_dir , get_field_dims_phi , get_field_dims_phi_dataloc procedure, public :: get_n_dir procedure, public :: get_n_phi generic, public :: get_n => get_n_dir , get_n_phi procedure, public :: get_padded_dims_phi procedure, public :: get_padded_dims_dir generic, public :: get_padded_dims => get_padded_dims_dir , get_padded_dims_phi procedure, public :: get_coordinates procedure, public :: set_sz procedure, public :: set_padded_dims Functions public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z Return Value type( mesh_t ) public pure function get_sz (self) result(sz) Getter for parameter SZ Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self Return Value integer public pure function get_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_global_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_dims_dataloc (data_loc, vert_dims, cell_dims) result(dims) Getter for domain dimensions Arguments Type Intent Optional Attributes Name integer, intent(in) :: data_loc integer, intent(in), dimension(3) :: vert_dims integer, intent(in), dimension(3) :: cell_dims Return Value integer, dimension(3) public pure function get_padded_dims_dir (self, dir) result(dims_padded) Getter for padded dimensions with structure in dir direction Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer, dimension(3) public pure function get_padded_dims_phi (self, phi) result(dims_padded) Getter for padded dimensions for field phi\nGets the field direction from the field itself Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) public pure function get_n_groups_dir (self, dir) result(n_groups) Getter for the number of groups for fields in direction dir Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir Return Value integer public pure function get_n_groups_phi (self, phi) result(n_groups) Getter for the number of groups for fields phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer public pure function get_field_dims_phi (self, phi) result(dims) Getter for the dimensions of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer, dimension(3) public pure function get_field_dims_phi_dataloc (self, phi, data_loc) result(dims) Getter for the dimensions of field phi where data is located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_field_dims_dir (self, dir, data_loc) result(dims) Getter for the dimensions of an array directed along dir where data would be located on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer public pure function get_coordinates (self, i, j, k) result(xloc) Get the physical location of a cell center with i,j,k local indices Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp), dimension(3) public pure function is_root (self) result(is_root_rank) Returns whether or not the current rank is the root rank Arguments Type Intent Optional Attributes Name class( parallel_t ), intent(in) :: self Return Value logical Subroutines public  subroutine set_padded_dims (self, vert_dims) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in), dimension(3) :: vert_dims public  subroutine set_sz (self, sz) Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: self integer, intent(in) :: sz public  subroutine domain_decomposition (mesh) Supports 1D, 2D, and 3D domain decomposition. Read more… Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(inout) :: mesh","tags":"","loc":"module/m_mesh.html"},{"title":"xcompact – x3d2","text":"Uses m_allocator m_cuda_tdsops m_cuda_backend m_base_backend m_cuda_allocator m_cuda_common m_omp_backend m_tdsops m_omp_common m_solver mpi m_common m_mesh Variables Type Attributes Name Initial class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator type( mesh_t ) :: mesh type( allocator_t ), pointer :: host_allocator type( solver_t ) :: solver type( cuda_backend_t ), target :: cuda_backend type( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs integer :: devnum type( omp_backend_t ), target :: omp_backend type( allocator_t ), target :: omp_allocator real(kind=dp) :: t_start real(kind=dp) :: t_end character(len=200) :: input_file character(len=20) :: BC_x (2) character(len=20) :: BC_y (2) character(len=20) :: BC_z (2) integer, dimension(3) :: dims_global integer, dimension(3) :: nproc_dir = 0 real(kind=dp), dimension(3) :: L_global integer :: nrank integer :: nproc integer :: ierr Namelists Namelist domain_params Variables Name Type Default Description L_global real(kind=dp) None dims_global integer None nproc_dir integer 0 BC_x character(len=20) None BC_y character(len=20) None BC_z character(len=20) None","tags":"","loc":"program/xcompact.html"},{"title":"  domain_params – x3d2\n","text":"Variables Name Type Default Description L_global real(kind=dp) None dims_global integer None nproc_dir integer 0 BC_x character(len=20) None BC_y character(len=20) None BC_z character(len=20) None","tags":"","loc":"namelist/domain_params.html"},{"title":"  solver_params – x3d2\n","text":"Variables Name Type Default Description Re real(kind=dp) None dt real(kind=dp) None n_iters integer None n_output integer None poisson_solver_type character(len=3) None time_intg character(len=3) None der1st_scheme character(len=30) None der2nd_scheme character(len=30) None interpl_scheme character(len=30) None stagder_scheme character(len=30) None","tags":"","loc":"namelist/solver_params.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_poisson_fft use m_allocator , only : field_t use m_common , only : dp , pi , CELL use m_tdsops , only : dirps_t use m_mesh , only : mesh_t , geo_t implicit none type , abstract :: poisson_fft_t !! FFT based Poisson solver !> Global dimensions integer :: nx_glob , ny_glob , nz_glob !> Local dimensions integer :: nx_loc , ny_loc , nz_loc !> Local dimensions in the permuted slabs integer :: nx_perm , ny_perm , nz_perm !> Local dimensions in the permuted slabs in spectral space integer :: nx_spec , ny_spec , nz_spec !> Offset in y direction in the permuted slabs in spectral space integer :: y_sp_st !> Local domain sized array storing the spectral equivalence constants complex ( dp ), allocatable , dimension (:, :, :) :: waves !> Wave numbers in x, y, and z complex ( dp ), allocatable , dimension (:) :: ax , bx , ay , by , az , bz contains procedure ( fft_forward ), deferred :: fft_forward procedure ( fft_backward ), deferred :: fft_backward procedure ( fft_postprocess ), deferred :: fft_postprocess procedure :: base_init procedure :: waves_set end type poisson_fft_t abstract interface subroutine fft_forward ( self , f_in ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in end subroutine fft_forward subroutine fft_backward ( self , f_out ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out end subroutine fft_backward subroutine fft_postprocess ( self ) import :: poisson_fft_t implicit none class ( poisson_fft_t ) :: self end subroutine fft_postprocess end interface contains subroutine base_init ( self , mesh , xdirps , ydirps , zdirps ) implicit none class ( poisson_fft_t ) :: self class ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps integer :: dims ( 3 ) dims = mesh % get_global_dims ( CELL ) self % nx_glob = dims ( 1 ); self % ny_glob = dims ( 2 ); self % nz_glob = dims ( 3 ) dims = mesh % get_dims ( CELL ) self % nx_loc = dims ( 1 ); self % ny_loc = dims ( 2 ); self % nz_loc = dims ( 3 ) ! 1D decomposition along Z in real domain, and along Y in spectral space if ( mesh % par % nproc_dir ( 1 ) /= 1 ) print * , 'nproc_dir in x-dir must be 1' if ( mesh % par % nproc_dir ( 2 ) /= 1 ) print * , 'nproc_dir in y-dir must be 1' self % nx_perm = self % nx_loc / mesh % par % nproc_dir ( 2 ) self % ny_perm = self % ny_loc / mesh % par % nproc_dir ( 3 ) self % nz_perm = self % nz_glob self % nx_spec = self % nx_loc / 2 + 1 self % ny_spec = self % ny_perm self % nz_spec = self % nz_perm self % y_sp_st = ( self % ny_loc / mesh % par % nproc_dir ( 3 )) * mesh % par % nrank_dir ( 3 ) allocate ( self % ax ( self % nx_glob ), self % bx ( self % nx_glob )) allocate ( self % ay ( self % ny_glob ), self % by ( self % ny_glob )) allocate ( self % az ( self % nz_glob ), self % bz ( self % nz_glob )) ! cuFFT 3D transform halves the first index. allocate ( self % waves ( self % nx_spec , self % ny_spec , self % nz_spec )) ! waves_set requires some of the preprocessed tdsops variables. call self % waves_set ( mesh % geo , xdirps , ydirps , zdirps ) end subroutine base_init subroutine waves_set ( self , geo , xdirps , ydirps , zdirps ) !! Spectral equivalence constants !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none class ( poisson_fft_t ) :: self type ( geo_t ), intent ( in ) :: geo type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps complex ( dp ), allocatable , dimension (:) :: xkx , xk2 , yky , yk2 , zkz , zk2 , & exs , eys , ezs integer :: nx , ny , nz , ix , iy , iz real ( dp ) :: w , wp , rlexs , rleys , rlezs , xtt , ytt , ztt , xt1 , yt1 , zt1 complex ( dp ) :: xt2 , yt2 , zt2 , xyzk real ( dp ) :: d , L integer :: i , j , k nx = self % nx_glob ; ny = self % ny_glob ; nz = self % nz_glob do i = 1 , nx self % ax ( i ) = sin (( i - 1 ) * pi / nx ) self % bx ( i ) = cos (( i - 1 ) * pi / nx ) end do do i = 1 , ny self % ay ( i ) = sin (( i - 1 ) * pi / ny ) self % by ( i ) = cos (( i - 1 ) * pi / ny ) end do do i = 1 , nz self % az ( i ) = sin (( i - 1 ) * pi / nz ) self % bz ( i ) = cos (( i - 1 ) * pi / nz ) end do ! Now kxyz allocate ( xkx ( nx ), xk2 ( nx ), exs ( nx )) allocate ( yky ( ny ), yk2 ( ny ), eys ( ny )) allocate ( zkz ( nz ), zk2 ( nz ), ezs ( nz )) xkx (:) = 0 ; xk2 (:) = 0 ; yky (:) = 0 ; yk2 (:) = 0 ; zkz (:) = 0 ; zk2 (:) = 0 ! periodic-x d = geo % d ( 1 ) L = geo % L ( 1 ) do i = 1 , nx / 2 + 1 w = 2 * pi * ( i - 1 ) / nx wp = xdirps % stagder_v2p % a * 2 * d * sin ( 0.5_dp * w ) & + xdirps % stagder_v2p % b * 2 * d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * xdirps % stagder_v2p % alpha * cos ( w )) xkx ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * wp / L ) exs ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * w / L ) xk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nx * wp / L ) ** 2 end do do i = nx / 2 + 2 , nx xkx ( i ) = xkx ( nx - i + 2 ) exs ( i ) = exs ( nx - i + 2 ) xk2 ( i ) = xk2 ( nx - i + 2 ) end do ! periodic-y d = geo % d ( 2 ) L = geo % L ( 2 ) do i = 1 , ny / 2 + 1 w = 2 * pi * ( i - 1 ) / ny wp = ydirps % stagder_v2p % a * 2 * d * sin ( 0.5_dp * w ) & + ydirps % stagder_v2p % b * 2 * d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * ydirps % stagder_v2p % alpha * cos ( w )) yky ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * wp / L ) eys ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * w / L ) yk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( ny * wp / L ) ** 2 end do do i = ny / 2 + 2 , ny yky ( i ) = yky ( ny - i + 2 ) eys ( i ) = eys ( ny - i + 2 ) yk2 ( i ) = yk2 ( ny - i + 2 ) end do ! periodic-z d = geo % d ( 3 ) L = geo % L ( 3 ) do i = 1 , nz / 2 + 1 w = 2 * pi * ( i - 1 ) / nz wp = zdirps % stagder_v2p % a * 2 * d * sin ( 0.5_dp * w ) & + zdirps % stagder_v2p % b * 2 * d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * zdirps % stagder_v2p % alpha * cos ( w )) zkz ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * wp / L ) ezs ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * w / L ) zk2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( nz * wp / L ) ** 2 end do do i = nz / 2 + 2 , nz zkz ( i ) = zkz ( nz - i + 2 ) ezs ( i ) = ezs ( nz - i + 2 ) zk2 ( i ) = zk2 ( nz - i + 2 ) end do do i = 1 , self % nx_spec do j = 1 , self % ny_spec do k = 1 , self % nz_spec ix = i ; iy = j + self % y_sp_st ; iz = k rlexs = real ( exs ( ix ), kind = dp ) * geo % d ( 1 ) rleys = real ( eys ( iy ), kind = dp ) * geo % d ( 2 ) rlezs = real ( ezs ( iz ), kind = dp ) * geo % d ( 3 ) xtt = 2 * ( xdirps % interpl_v2p % a * cos ( rlexs * 0.5_dp ) & + xdirps % interpl_v2p % b * cos ( rlexs * 1.5_dp ) & + xdirps % interpl_v2p % c * cos ( rlexs * 2.5_dp ) & + xdirps % interpl_v2p % d * cos ( rlexs * 3.5_dp )) ytt = 2 * ( ydirps % interpl_v2p % a * cos ( rleys * 0.5_dp ) & + ydirps % interpl_v2p % b * cos ( rleys * 1.5_dp ) & + ydirps % interpl_v2p % c * cos ( rleys * 2.5_dp ) & + ydirps % interpl_v2p % d * cos ( rleys * 3.5_dp )) ztt = 2 * ( zdirps % interpl_v2p % a * cos ( rlezs * 0.5_dp ) & + zdirps % interpl_v2p % b * cos ( rlezs * 1.5_dp ) & + zdirps % interpl_v2p % c * cos ( rlezs * 2.5_dp ) & + zdirps % interpl_v2p % d * cos ( rlezs * 3.5_dp )) xt1 = 1._dp + 2 * xdirps % interpl_v2p % alpha * cos ( rlexs ) yt1 = 1._dp + 2 * ydirps % interpl_v2p % alpha * cos ( rleys ) zt1 = 1._dp + 2 * zdirps % interpl_v2p % alpha * cos ( rlezs ) xt2 = xk2 ( ix ) * ((( ytt / yt1 ) * ( ztt / zt1 )) ** 2 ) yt2 = yk2 ( iy ) * ((( xtt / xt1 ) * ( ztt / zt1 )) ** 2 ) zt2 = zk2 ( iz ) * ((( xtt / xt1 ) * ( ytt / yt1 )) ** 2 ) xyzk = xt2 + yt2 + zt2 self % waves ( i , j , k ) = xyzk end do end do end do end subroutine waves_set end module m_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90.html"},{"title":"tdsops.f90 – x3d2","text":"Source Code module m_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp , pi , VERT , CELL , none use m_mesh , only : mesh_t implicit none type :: tdsops_t !! Tridiagonal Solver Operators class. !! !! Operator arrays are preprocessed in this class based on the arguments !! provided. dist_fw and dist_bw are used in the first phase of the !! distributed tridiagonal solver algorithm. dist_sa and dist_sc are used !! in the final substitution phase. See the kernels_dist.f90 files in the !! relevant backend folders. !! coeff arrays define the specific rules of building the RHS !! corresponding to the tridiagonal system to be solved, and used only in !! the first phase of the distributed algorithm when building the RHS. !! If a boundary condition is defined then coeffs_s and coeffs_e differ !! from coeffs array and define the RHS rule for the first and last 4 !! entries in the tridiagonal system (n_halo = 4). !! !! This class does not know about the current rank or its relative !! location among other ranks. All the operator arrays here are used when !! executing a distributed tridiagonal solver phase one or two. real ( dp ), allocatable , dimension (:) :: dist_fw , dist_bw , & !! fw/bw phase dist_sa , dist_sc , & !! back subs. dist_af !! the auxiliary factors real ( dp ), allocatable , dimension (:) :: thom_f , thom_s , thom_w , thom_p real ( dp ), allocatable :: coeffs (:), coeffs_s (:, :), coeffs_e (:, :) real ( dp ) :: alpha , a , b , c = 0._dp , d = 0._dp logical :: periodic integer :: tds_n integer :: dir integer :: n_halo contains procedure :: deriv_1st , deriv_2nd , interpl_mid , stagder_1st procedure :: preprocess_dist , preprocess_thom end type tdsops_t interface tdsops_t module procedure tdsops_init end interface tdsops_t type :: dirps_t !! Directional tridiagonal solver container. !! !! This class contains the preprocessed tridiagonal solvers for operating !! in each coordinate direction. class ( tdsops_t ), allocatable :: der1st , der1st_sym , der2nd , der2nd_sym , & stagder_v2p , stagder_p2v , interpl_v2p , interpl_p2v integer :: dir end type dirps_t contains function tdsops_init ( tds_n , delta , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) result ( tdsops ) !! Constructor function for the tdsops_t class. !! !! 'n', 'delta', 'operation', and 'scheme' are necessary arguments. !! Number of points 'n', distance between two points 'delta', the !! 'operation' the tridiagonal system defines, and the 'scheme' that !! specifies the exact scheme we choose to apply for the operation. !! The remaining arguments are optional. !! 'from_to' is necessary for interpolation and staggared derivative, and !! it can be 'v2p' or 'p2v'. !! If the specific region the instance is operating is not a boundary !! region, then 'bc_start' and 'bc_end' are either 'null' or not defined. !! 'sym' is relevant when the boundary condition is free-slip. If sym is !! .true. then it means the field we operate on is assumed to be an even !! function (symmetric) accross the boundary. If it is .false. it means !! that the field is assumed to be an odd function (anti-symmetric). !! 'c_nu', 'nu0_nu' are relevant when operation is second order !! derivative and scheme is compact6-hyperviscous. implicit none type ( tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: tds_n real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo !! Number of halo cells character ( * ), optional , intent ( in ) :: from_to !! 'v2p' or 'p2v' character ( * ), optional , intent ( in ) :: bc_start , bc_end !! Boundary Cond. logical , optional , intent ( in ) :: sym !! (==npaire), only for Neumann BCs real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu !! params for hypervisc. integer :: n_stencil tdsops % tds_n = tds_n if ( present ( n_halo )) then tdsops % n_halo = n_halo if ( n_halo /= 4 ) then write ( stderr , '(\"Warning: n_halo is set to \", i2, \"be careful! & &The default is 4 and there are quite a few & &places where things are hardcoded assuming & &n_halo is 4.\")' ) n_halo end if else tdsops % n_halo = 4 end if n_stencil = 2 * tdsops % n_halo + 1 ! preprocessed coefficient arrays for the distributed algorithm allocate ( tdsops % dist_fw ( tds_n ), tdsops % dist_bw ( tds_n )) allocate ( tdsops % dist_sa ( tds_n ), tdsops % dist_sc ( tds_n )) allocate ( tdsops % dist_af ( tds_n )) ! preprocessed coefficient arrays for the Thomas algorithm allocate ( tdsops % thom_f ( tds_n ), tdsops % thom_s ( tds_n )) allocate ( tdsops % thom_w ( tds_n ), tdsops % thom_p ( tds_n )) ! RHS coefficient arrays allocate ( tdsops % coeffs ( n_stencil )) allocate ( tdsops % coeffs_s ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e ( n_stencil , tdsops % n_halo )) tdsops % periodic = bc_start == 'periodic' . and . bc_end == 'periodic' if ( operation == 'first-deriv' ) then call tdsops % deriv_1st ( delta , scheme , bc_start , bc_end , sym ) else if ( operation == 'second-deriv' ) then call tdsops % deriv_2nd ( delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) else if ( operation == 'interpolate' ) then call tdsops % interpl_mid ( scheme , from_to , bc_start , bc_end , sym ) else if ( operation == 'stag-deriv' ) then call tdsops % stagder_1st ( delta , scheme , from_to , bc_start , bc_end , sym ) else error stop 'operation is not defined' end if end function tdsops_init pure function get_tds_n ( mesh , dir , from_to ) result ( tds_n ) !! Get the tds_n size based on the from_to value (and the mesh) class ( mesh_t ), intent ( in ) :: mesh integer , intent ( in ) :: dir character ( * ), optional , intent ( in ) :: from_to integer :: tds_n integer :: data_loc data_loc = VERT if ( present ( from_to )) then if ( from_to == \"v2p\" ) then data_loc = CELL end if end if tds_n = mesh % get_n ( dir , data_loc ) end function subroutine deriv_1st ( self , delta , scheme , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , afi , bfi integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 2 ) error stop 'First derivative require n_halo >= 2' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if ! alpha is alfa select case ( scheme ) case ( 'compact6' ) alpha = 1._dp / 3._dp afi = 7._dp / 9._dp / delta bfi = 1._dp / 3 6._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = afi ; self % b = bfi self % coeffs (:) = [ 0._dp , 0._dp , - bfi , - afi , & 0._dp , & afi , bfi , 0._dp , 0._dp ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % tds_n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp select case ( bc_start ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & - bfi , & afi , bfi , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 2 * afi , 2 * bfi , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & bfi , & afi , bfi , 0._dp , 0._dp ] end if case ( 'dirichlet' ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2.5_dp , & 2._dp , 0.5_dp , 0._dp , 0._dp ] self % coeffs_s (:, 1 ) = self % coeffs_s (:, 1 ) / delta ! second line self % dist_sa ( 2 ) = 0.25_dp self % dist_sc ( 2 ) = 0.25_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = self % coeffs_s (:, 2 ) / delta end select select case ( bc_end ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & bfi , & afi , 0._dp , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 2 * bfi , - 2 * afi , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & - bfi , & afi , 0._dp , 0._dp , 0._dp ] end if case ( 'dirichlet' ) ! last line self % dist_sa ( n ) = 2._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 0.5_dp , - 2._dp , & 2.5_dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo ) = self % coeffs_e (:, n_halo ) / delta ! second last line self % dist_sa ( n - 1 ) = 0.25_dp self % dist_sc ( n - 1 ) = 0.25_dp self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = self % coeffs_e (:, n_halo - 1 ) / delta end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine deriv_1st subroutine deriv_2nd ( self , delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , asi , bsi , csi , dsi real ( dp ) :: dpis3 , xnpi2 , xmpi2 , den , d2 , temp1 , temp2 integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 4 ) error stop 'Second derivative require n_halo >= 4' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if d2 = delta * delta ! alpha is alsa select case ( scheme ) case ( 'compact6' ) alpha = 2._dp / 1 1._dp asi = 1 2._dp / 1 1._dp / d2 bsi = 3._dp / 4 4._dp / d2 csi = 0._dp dsi = 0._dp case ( 'compact6-hyperviscous' ) if ( present ( c_nu ) . and . present ( nu0_nu )) then dpis3 = 2._dp * pi / 3._dp xnpi2 = pi * pi * ( 1._dp + nu0_nu ) xmpi2 = dpis3 * dpis3 * ( 1._dp + c_nu * nu0_nu ) den = 40 5._dp * xnpi2 - 64 0._dp * xmpi2 + 14 4._dp alpha = 0.5_dp - ( 32 0._dp * xmpi2 - 129 6._dp ) / den asi = - ( 432 9._dp * xnpi2 / 8._dp - 3 2._dp * xmpi2 & - 14 0._dp * xnpi2 * xmpi2 + 28 6._dp ) / den / d2 bsi = ( 211 5._dp * xnpi2 - 179 2._dp * xmpi2 & - 28 0._dp * xnpi2 * xmpi2 + 132 8._dp ) / den / ( 4._dp * d2 ) csi = - ( 769 5._dp * xnpi2 / 8._dp + 28 8._dp * xmpi2 & - 18 0._dp * xnpi2 * xmpi2 - 257 4._dp ) / den / ( 9._dp * d2 ) dsi = ( 19 8._dp * xnpi2 + 12 8._dp * xmpi2 & - 4 0._dp * xnpi2 * xmpi2 - 73 6._dp ) / den / ( 1 6._dp * d2 ) else error stop 'compact6-hyperviscous requires c_nu and nu0_nu' end if case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = asi ; self % b = bsi ; self % c = csi ; self % d = dsi self % coeffs (:) = [ dsi , csi , bsi , asi , & - 2._dp * ( asi + bsi + csi + dsi ), & asi , bsi , csi , dsi ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % tds_n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp select case ( bc_start ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 2 * asi , 2 * bsi , 2 * csi , 2 * dsi ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi + csi , bsi + dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi + csi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , csi , bsi + dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi - csi , bsi - dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi - csi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , - csi , bsi - dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] end if case ( 'dirichlet' ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 1 1._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 1 3._dp / d2 , & - 2 7._dp / d2 , 1 5._dp / d2 , - 1._dp / d2 , 0._dp ] ! second line self % dist_sa ( 2 ) = 0.1_dp self % dist_sc ( 2 ) = 0.1_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third line self % dist_sa ( 3 ) = 2._dp / 1 1._dp self % dist_sc ( 3 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth line is same as third self % dist_sa ( 4 ) = 2._dp / 1 1._dp self % dist_sc ( 4 ) = 2._dp / 1 1._dp self % coeffs_s (:, 4 ) = self % coeffs_s (:, 3 ) end select select case ( bc_end ) case ( 'neumann' ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi + dsi , asi + csi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi + csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi + dsi , csi , 0._dp ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi - dsi , asi - csi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi - csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi - dsi , - csi , 0._dp ] end if case ( 'dirichlet' ) ! last line self % dist_sa ( n ) = 1 1._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , - 1._dp / d2 , 1 5._dp / d2 , - 2 7._dp / d2 , & 1 3._dp / d2 , & 0._dp , 0._dp , 0._dp , 0._dp ] ! second last line self % dist_sa ( n - 1 ) = 0.1_dp self % dist_sc ( n - 1 ) = 0.1_dp self % coeffs_e (:, 3 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third last line self % dist_sa ( n - 2 ) = 2._dp / 1 1._dp self % dist_sc ( n - 2 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_e (:, 2 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth last line is same as third last self % dist_sa ( n - 3 ) = 2._dp / 1 1._dp self % dist_sc ( n - 3 ) = 2._dp / 1 1._dp self % coeffs_e (:, 1 ) = self % coeffs_e (:, 2 ) end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine deriv_2nd subroutine interpl_mid ( self , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: scheme , from_to character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aici , bici , cici , dici integer :: i , n , n_halo if ( self % n_halo < 4 ) error stop 'Interpolation require n_halo >= 4' ! alpha is ailcai select case ( scheme ) case ( 'classic' ) alpha = 0.3_dp aici = 0.75_dp bici = 0.05_dp cici = 0._dp dici = 0._dp case ( 'optimised' ) alpha = 0.461658_dp dici = 0.00146508_dp aici = ( 7 5._dp + 7 0._dp * alpha - 64 0._dp * dici ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha + 230 4._dp * dici ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha - 128 0._dp * dici ) / 25 6._dp case ( 'aggressive' ) alpha = 0.49_dp aici = ( 7 5._dp + 7 0._dp * alpha ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha ) / 25 6._dp dici = 0._dp case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aici ; self % b = bici ; self % c = cici ; self % d = dici select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , dici , cici , bici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) self % coeffs (:) = [ dici , cici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % tds_n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp if (( bc_start == 'dirichlet' ) . or . ( bc_start == 'neumann' )) then self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & aici , & aici + bici , bici + cici , cici + dici , dici ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , bici , & aici + cici , & aici + dici , bici , cici , dici ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , cici , bici + dici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 2 * aici , & 2 * bici , 2 * cici , 2 * dici , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , aici + bici , & aici + cici , & bici + dici , cici , dici , 0._dp ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bici + cici , aici + dici , & aici , & bici , cici , dici , 0._dp ] self % coeffs_s (:, 4 ) = [ 0._dp , cici + dici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select end if if (( bc_end == 'dirichlet' ) . or . ( bc_end == 'neumann' )) then self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, 4 ) = [ 0._dp , dici , cici + dici , bici + cici , & aici + bici , & aici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ 0._dp , dici , cici , bici , & aici + dici , & aici + cici , bici , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ 0._dp , dici , cici , bici , & aici , & aici , bici + dici , cici , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 2 * alpha self % coeffs_e (:, 4 ) = [ 2 * dici , 2 * cici , 2 * bici , 2 * aici , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dici , cici , bici + dici , aici + cici , & aici + bici , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dici , cici , bici , aici , & aici + dici , & bici + cici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dici , cici , bici , aici , & aici , & bici , cici + dici , 0._dp , 0._dp ] end select end if call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine interpl_mid subroutine stagder_1st ( self , delta , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme , from_to character ( * ), optional , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aci , bci integer :: i , n , n_halo if ( self % n_halo < 2 ) error stop 'Staggared deriv require n_halo >= 2' ! alpha is alcai select case ( scheme ) case ( 'compact6' ) alpha = 9._dp / 6 2._dp aci = 6 3._dp / 6 2._dp / delta bci = 1 7._dp / 6 2._dp / 3._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aci ; self % b = bci select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) self % coeffs (:) = [ 0._dp , 0._dp , - bci , - aci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % tds_n n_halo = self % n_halo allocate ( dist_b ( n )) dist_b (:) = 1._dp if (( bc_start == 'dirichlet' ) . or . ( bc_start == 'neumann' )) then self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - aci - 2 * bci , & aci + bci , bci , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - aci - bci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select end if if (( bc_end == 'dirichlet' ) . or . ( bc_end == 'neumann' )) then self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci - bci , & aci + 2 * bci , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bci , - aci , & aci + bci , & 0._dp , 0._dp , 0._dp , 0._dp ] end select end if call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine stagder_1st subroutine preprocess_dist ( self , dist_b ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), dimension (:), intent ( in ) :: dist_b integer :: i integer :: n n = self % tds_n ! Ref DOI: 10.1109/MCSE.2021.3130544 ! Algorithm 3 in page 4 ! First two lines first do i = 1 , 2 self % dist_sa ( i ) = self % dist_sa ( i ) / dist_b ( i ) self % dist_sc ( i ) = self % dist_sc ( i ) / dist_b ( i ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_af ( i ) = 1._dp / dist_b ( i ) end do ! Then the remaining in the forward pass do i = 3 , n ! Algorithm 3 in ref obtains 'r' coeffs on the fly in line 7. ! As we have to solve many RHSs with the same tridiagonal system, ! it is better to do a preprocessing first. ! So lets store 'r' coeff in dist_fw array. self % dist_fw ( i ) = 1._dp / ( dist_b ( i ) & - self % dist_sa ( i ) * self % dist_sc ( i - 1 )) ! dist_af is 'a_i' in line 7 of Algorithm 3 in ref. self % dist_af ( i ) = self % dist_sa ( i ) ! We store a_i&#94;* and c_i&#94;* in dist_sa and dist_sc because ! we need them later in the substitution phase. self % dist_sa ( i ) = - self % dist_fw ( i ) * self % dist_sa ( i ) & * self % dist_sa ( i - 1 ) self % dist_sc ( i ) = self % dist_fw ( i ) * self % dist_sc ( i ) end do ! backward pass starting in line 12 of Algorithm 3. do i = n - 2 , 2 , - 1 self % dist_sa ( i ) = self % dist_sa ( i ) & - self % dist_sc ( i ) * self % dist_sa ( i + 1 ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_sc ( i ) = - self % dist_sc ( i ) * self % dist_sc ( i + 1 ) end do ! Line 17 and 18 are tricky ! First we have a new 'r', we need it. ! And for 'r' we need c_0&#94;*... ! Now examine closely, c_0&#94;* is set in line 4 and never overwritten! ! So we can use dist_sc(1) as is in place of c_0&#94;*. ! We need to store this new 'r' somewhere ... ! dist_fw(1) is never used, so store this extra 'r' factor here instead self % dist_fw ( 1 ) = 1._dp / ( 1._dp - self % dist_sc ( 1 ) * self % dist_sa ( 2 )) ! Finally Line 19 and 20 in Algorithm 3 in ref. self % dist_sa ( 1 ) = self % dist_fw ( 1 ) * self % dist_sa ( 1 ) self % dist_sc ( 1 ) = - self % dist_fw ( 1 ) * self % dist_sc ( 1 ) * self % dist_sc ( 2 ) end subroutine preprocess_dist subroutine preprocess_thom ( self , b ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), dimension (:), intent ( in ) :: b integer :: i , n n = self % tds_n self % thom_w = b self % thom_f = self % dist_sc if ( self % periodic ) then self % thom_w ( 1 ) = 2._dp self % thom_w ( self % tds_n ) = 1._dp + self % alpha * self % alpha end if self % thom_s ( 1 ) = 0._dp do i = 2 , n self % thom_s ( i ) = self % dist_sa ( i ) / self % thom_w ( i - 1 ) self % thom_w ( i ) = self % thom_w ( i ) - self % thom_f ( i - 1 ) * self % thom_s ( i ) end do do i = 1 , n self % thom_w ( i ) = 1._dp / self % thom_w ( i ) end do self % thom_p = [ - 1._dp , ( 0._dp , i = 2 , self % tds_n - 1 ), self % alpha ] do i = 2 , n self % thom_p ( i ) = self % thom_p ( i ) - self % thom_p ( i - 1 ) * self % thom_s ( i ) end do self % thom_p ( n ) = self % thom_p ( n ) * self % thom_w ( n ) do i = n - 1 , 1 , - 1 self % thom_p ( i ) = self % thom_w ( i ) * ( self % thom_p ( i ) & - self % thom_f ( i ) * self % thom_p ( i + 1 )) end do end subroutine preprocess_thom end module m_tdsops","tags":"","loc":"sourcefile/tdsops.f90.html"},{"title":"tdsops.f90 – x3d2","text":"Source Code module m_cuda_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp use m_tdsops , only : tdsops_t , tdsops_init implicit none type , extends ( tdsops_t ) :: cuda_tdsops_t !! CUDA extension of the Tridiagonal Solver Operators class. !! !! Regular tdsops_t class is initiated and the coefficient arrays are !! copied into device arrays so that cuda kernels can use them. real ( dp ), device , allocatable :: dist_fw_dev (:), dist_bw_dev (:), & dist_sa_dev (:), dist_sc_dev (:), & dist_af_dev (:) real ( dp ), device , allocatable :: thom_f_dev (:), thom_s_dev (:), & thom_w_dev (:), thom_p_dev (:) real ( dp ), device , allocatable :: coeffs_dev (:), & coeffs_s_dev (:, :), coeffs_e_dev (:, :) contains end type cuda_tdsops_t interface cuda_tdsops_t module procedure cuda_tdsops_init end interface cuda_tdsops_t contains function cuda_tdsops_init ( n , delta , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) & result ( tdsops ) !! Constructor function for the cuda_tdsops_t class. !! See tdsops_t for details. implicit none type ( cuda_tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: n real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu integer :: n_stencil tdsops % tdsops_t = tdsops_init ( n , delta , operation , scheme , n_halo , & from_to , bc_start , bc_end , sym , & c_nu , nu0_nu ) n_stencil = 2 * tdsops % n_halo + 1 allocate ( tdsops % dist_fw_dev ( n ), tdsops % dist_bw_dev ( n )) allocate ( tdsops % dist_sa_dev ( n ), tdsops % dist_sc_dev ( n )) allocate ( tdsops % dist_af_dev ( n )) allocate ( tdsops % thom_f_dev ( n ), tdsops % thom_s_dev ( n )) allocate ( tdsops % thom_w_dev ( n ), tdsops % thom_p_dev ( n )) allocate ( tdsops % coeffs_dev ( n_stencil )) allocate ( tdsops % coeffs_s_dev ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e_dev ( n_stencil , tdsops % n_halo )) tdsops % dist_fw_dev (:) = tdsops % dist_fw (:) tdsops % dist_bw_dev (:) = tdsops % dist_bw (:) tdsops % dist_sa_dev (:) = tdsops % dist_sa (:) tdsops % dist_sc_dev (:) = tdsops % dist_sc (:) tdsops % dist_af_dev (:) = tdsops % dist_af (:) tdsops % thom_f_dev (:) = tdsops % thom_f (:) tdsops % thom_s_dev (:) = tdsops % thom_s (:) tdsops % thom_w_dev (:) = tdsops % thom_w (:) tdsops % thom_p_dev (:) = tdsops % thom_p (:) tdsops % coeffs_dev (:) = tdsops % coeffs (:) tdsops % coeffs_s_dev (:, :) = tdsops % coeffs_s (:, :) tdsops % coeffs_e_dev (:, :) = tdsops % coeffs_e (:, :) end function cuda_tdsops_init end module m_cuda_tdsops","tags":"","loc":"sourcefile/tdsops.f90~2.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_omp_poisson_fft use m_allocator , only : field_t use m_common , only : dp use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_mesh , only : mesh_t implicit none type , extends ( poisson_fft_t ) :: omp_poisson_fft_t !! FFT based Poisson solver !! It can only handle 1D decompositions along z direction. complex ( dp ), allocatable , dimension (:, :, :) :: c_x , c_y , c_z contains procedure :: fft_forward => fft_forward_omp procedure :: fft_backward => fft_backward_omp procedure :: fft_postprocess => fft_postprocess_omp end type omp_poisson_fft_t interface omp_poisson_fft_t module procedure init end interface omp_poisson_fft_t private :: init contains function init ( mesh , xdirps , ydirps , zdirps ) result ( poisson_fft ) implicit none class ( mesh_t ), intent ( in ) :: mesh class ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps type ( omp_poisson_fft_t ) :: poisson_fft call poisson_fft % base_init ( mesh , xdirps , ydirps , zdirps ) end function init subroutine fft_forward_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in end subroutine fft_forward_omp subroutine fft_backward_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out end subroutine fft_backward_omp subroutine fft_postprocess_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self end subroutine fft_postprocess_omp end module m_omp_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90~2.html"},{"title":"thomas.f90 – x3d2","text":"Source Code module m_cuda_kernels_thom use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine der_univ_thom ( & du , u , coeffs_s , coeffs_e , coeffs , n , thom_f , thom_s , thom_w & ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: u real ( dp ), device , intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e real ( dp ), device , intent ( in ), dimension (:) :: coeffs integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ), dimension (:) :: thom_f , thom_s , thom_w integer :: i , j , b real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , temp_du i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) du ( i , 1 , b ) = coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = du ( i , 1 , b ) du ( i , 2 , b ) = coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = du ( i , 2 , b ) - du ( i , 1 , b ) * thom_s ( 2 ) du ( i , 3 , b ) = coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = du ( i , 3 , b ) - du ( i , 2 , b ) * thom_s ( 3 ) du ( i , 4 , b ) = coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = du ( i , 4 , b ) - du ( i , 3 , b ) * thom_s ( 4 ) do j = 5 , n - 4 temp_du = c_m4 * u ( i , j - 4 , b ) + c_m3 * u ( i , j - 3 , b ) & + c_m2 * u ( i , j - 2 , b ) + c_m1 * u ( i , j - 1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , j + 1 , b ) + c_p2 * u ( i , j + 2 , b ) & + c_p3 * u ( i , j + 3 , b ) + c_p4 * u ( i , j + 4 , b ) du ( i , j , b ) = temp_du - du ( i , j - 1 , b ) * thom_s ( j ) end do j = n - 3 du ( i , j , b ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n - 2 du ( i , j , b ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n - 1 du ( i , j , b ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n du ( i , j , b ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 4 ) * u ( i , j , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) ! Backward pass of the Thomas algorithm du ( i , n , b ) = du ( i , n , b ) * thom_w ( n ) do j = n - 1 , 1 , - 1 du ( i , j , b ) = ( du ( i , j , b ) - thom_f ( j ) * du ( i , j + 1 , b )) * thom_w ( j ) end do end subroutine der_univ_thom attributes ( global ) subroutine der_univ_thom_per ( & du , u , coeffs , n , alpha , thom_f , thom_s , thom_w , thom_p & ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: u real ( dp ), device , intent ( in ), dimension (:) :: coeffs integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: alpha real ( dp ), device , intent ( in ), dimension (:) :: thom_f , thom_s , thom_w , & thom_p integer :: i , j , b integer :: jm4 , jm3 , jm2 , jm1 , jp1 , jp2 , jp3 , jp4 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 real ( dp ) :: temp_du , ss i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) do j = 1 , n jm4 = modulo ( j - 5 , n ) + 1 jm3 = modulo ( j - 4 , n ) + 1 jm2 = modulo ( j - 3 , n ) + 1 jm1 = modulo ( j - 2 , n ) + 1 jp1 = modulo ( j - n , n ) + 1 jp2 = modulo ( j - n + 1 , n ) + 1 jp3 = modulo ( j - n + 2 , n ) + 1 jp4 = modulo ( j - n + 3 , n ) + 1 temp_du = c_m4 * u ( i , jm4 , b ) + c_m3 * u ( i , jm3 , b ) & + c_m2 * u ( i , jm2 , b ) + c_m1 * u ( i , jm1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , jp1 , b ) + c_p2 * u ( i , jp2 , b ) & + c_p3 * u ( i , jp3 , b ) + c_p4 * u ( i , jp4 , b ) du ( i , j , b ) = temp_du - du ( i , jm1 , b ) * thom_s ( j ) end do ! Backward pass of the Thomas algorithm du ( i , n , b ) = du ( i , n , b ) * thom_w ( n ) do j = n - 1 , 1 , - 1 du ( i , j , b ) = ( du ( i , j , b ) - thom_f ( j ) * du ( i , j + 1 , b )) * thom_w ( j ) end do ! Periodic final pass ss = ( du ( i , 1 , b ) - alpha * du ( i , n , b )) & / ( 1._dp + thom_p ( 1 ) - alpha * thom_p ( n )) do j = 1 , n du ( i , j , b ) = du ( i , j , b ) - ss * thom_p ( j ) end do end subroutine der_univ_thom_per end module m_cuda_kernels_thom","tags":"","loc":"sourcefile/thomas.f90.html"},{"title":"exec_dist.f90 – x3d2","text":"Source Code module m_cuda_exec_dist use cudafor use mpi use m_common , only : dp use m_cuda_common , only : SZ use m_cuda_kernels_dist , only : der_univ_dist , der_univ_subs , & transeq_3fused_dist , transeq_3fused_subs use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , blocks , threads & ) implicit none ! du = d(u) real ( dp ), device , dimension (:, :, :), intent ( out ) :: du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( cuda_tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call der_univ_dist <<< blocks , threads >>> ( & !& du , du_send_s , du_send_e , u , u_recv_s , u_recv_e , & tdsops % coeffs_s_dev , tdsops % coeffs_e_dev , tdsops % coeffs_dev , & tdsops % tds_n , tdsops % dist_fw_dev , tdsops % dist_bw_dev , & tdsops % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call der_univ_subs <<< blocks , threads >>> ( & !& du , du_recv_s , du_recv_e , & tdsops % tds_n , tdsops % dist_sa_dev , tdsops % dist_sc_dev & ) end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_3fused ( & r_u , u , u_recv_s , u_recv_e , v , v_recv_s , v_recv_e , & du , dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & der1st , der2nd , nu , nproc , pprev , pnext , blocks , threads & ) implicit none ! r_u = -1/2*(v*d1(u) + d1(u*v)) + nu*d2(u) real ( dp ), device , dimension (:, :, :), intent ( out ) :: r_u real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: du , dud , d2u real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e type ( cuda_tdsops_t ), intent ( in ) :: der1st , der2nd real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call transeq_3fused_dist <<< blocks , threads >>> ( & !& du , dud , d2u , & du_send_s , du_send_e , & dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , der1st % tds_n , & der1st % coeffs_s_dev , der1st % coeffs_e_dev , der1st % coeffs_dev , & der1st % dist_fw_dev , der1st % dist_bw_dev , der1st % dist_af_dev , & der2nd % coeffs_s_dev , der2nd % coeffs_e_dev , der2nd % coeffs_dev , & der2nd % dist_fw_dev , der2nd % dist_bw_dev , der2nd % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_3fields ( & du_recv_s , du_recv_e , dud_recv_s , dud_recv_e , & d2u_recv_s , d2u_recv_e , & du_send_s , du_send_e , dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext & ) call transeq_3fused_subs <<< blocks , threads >>> ( & !& r_u , v , du , dud , d2u , & du_recv_s , du_recv_e , & dud_recv_s , dud_recv_e , & d2u_recv_s , d2u_recv_e , & der1st % dist_sa_dev , der1st % dist_sc_dev , & der2nd % dist_sa_dev , der2nd % dist_sc_dev , & der1st % tds_n , nu & ) end subroutine exec_dist_transeq_3fused end module m_cuda_exec_dist","tags":"","loc":"sourcefile/exec_dist.f90.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_cuda_common implicit none integer , parameter :: SZ = 32 end module m_cuda_common","tags":"","loc":"sourcefile/common.f90.html"},{"title":"exec_dist.f90 – x3d2","text":"Source Code module m_omp_exec_dist use mpi use m_common , only : dp , VERT use m_omp_common , only : SZ use m_omp_kernels_dist , only : der_univ_dist , der_univ_subs use m_tdsops , only : tdsops_t use m_omp_sendrecv , only : sendrecv_fields implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , n_groups ) implicit none ! du = d(u) real ( dp ), dimension (:, :, :), intent ( out ) :: du real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_groups integer :: n_data integer :: k n_data = SZ * n_groups !$omp parallel do do k = 1 , n_groups call der_univ_dist ( & du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops % coeffs_s , tdsops % coeffs_e , tdsops % coeffs , tdsops % tds_n , & tdsops % dist_fw , tdsops % dist_bw , tdsops % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_groups call der_univ_subs ( du (:, :, k ), & du_recv_s (:, :, k ), du_recv_e (:, :, k ), & tdsops % tds_n , tdsops % dist_sa , tdsops % dist_sc ) end do !$omp end parallel do end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_compact ( & rhs , du , dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , nu , nproc , pprev , pnext , n_groups ) implicit none ! du = d(u) real ( dp ), dimension (:, :, :), intent ( out ) :: rhs , du , dud , d2u ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e type ( tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_groups real ( dp ), dimension (:, :), allocatable :: ud , ud_recv_s , ud_recv_e integer :: n_data , n_halo integer :: k , i , j , n ! TODO: don't hardcode n_halo n_halo = 4 n = tdsops_du % tds_n n_data = SZ * n_groups allocate ( ud ( SZ , n )) allocate ( ud_recv_e ( SZ , n_halo )) allocate ( ud_recv_s ( SZ , n_halo )) !$omp parallel do private(ud, ud_recv_e, ud_recv_s) do k = 1 , n_groups call der_univ_dist ( & du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_du % coeffs_s , tdsops_du % coeffs_e , tdsops_du % coeffs , & n , tdsops_du % dist_fw , tdsops_du % dist_bw , tdsops_du % dist_af & ) call der_univ_dist ( & d2u (:, :, k ), d2u_send_s (:, :, k ), d2u_send_e (:, :, k ), u (:, :, k ), & u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_d2u % coeffs_s , tdsops_d2u % coeffs_e , tdsops_d2u % coeffs , & n , tdsops_d2u % dist_fw , tdsops_d2u % dist_bw , & tdsops_d2u % dist_af & ) ! Handle dud by locally generating u*v do j = 1 , n !$omp simd do i = 1 , SZ ud ( i , j ) = u ( i , j , k ) * v ( i , j , k ) end do !$omp end simd end do do j = 1 , n_halo !$omp simd do i = 1 , SZ ud_recv_s ( i , j ) = u_recv_s ( i , j , k ) * v_recv_s ( i , j , k ) ud_recv_e ( i , j ) = u_recv_e ( i , j , k ) * v_recv_e ( i , j , k ) end do !$omp end simd end do call der_univ_dist ( & dud (:, :, k ), dud_send_s (:, :, k ), dud_send_e (:, :, k ), ud (:, :), & ud_recv_s (:, :), ud_recv_e (:, :), & tdsops_dud % coeffs_s , tdsops_dud % coeffs_e , tdsops_dud % coeffs , & n , tdsops_dud % dist_fw , tdsops_dud % dist_bw , & tdsops_dud % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( dud_recv_s , dud_recv_e , dud_send_s , dud_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( d2u_recv_s , d2u_recv_e , d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_groups call der_univ_subs ( du (:, :, k ), & du_recv_s (:, :, k ), du_recv_e (:, :, k ), & n , tdsops_du % dist_sa , tdsops_du % dist_sc ) call der_univ_subs ( dud (:, :, k ), & dud_recv_s (:, :, k ), dud_recv_e (:, :, k ), & n , tdsops_dud % dist_sa , tdsops_dud % dist_sc ) call der_univ_subs ( d2u (:, :, k ), & d2u_recv_s (:, :, k ), d2u_recv_e (:, :, k ), & n , tdsops_d2u % dist_sa , tdsops_d2u % dist_sc ) do j = 1 , n !$omp simd do i = 1 , SZ rhs ( i , j , k ) = - 0.5_dp * ( v ( i , j , k ) * du ( i , j , k ) + dud ( i , j , k )) & + nu * d2u ( i , j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine exec_dist_transeq_compact end module m_omp_exec_dist","tags":"","loc":"sourcefile/exec_dist.f90~2.html"},{"title":"xcompact.f90 – x3d2","text":"Source Code program xcompact use mpi use m_allocator use m_base_backend use m_common , only : pi use m_solver , only : solver_t use m_tdsops , only : tdsops_t use m_mesh #ifdef CUDA use m_cuda_allocator use m_cuda_backend use m_cuda_common , only : SZ use m_cuda_tdsops , only : cuda_tdsops_t #else use m_omp_backend use m_omp_common , only : SZ #endif implicit none class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator type ( mesh_t ) :: mesh type ( allocator_t ), pointer :: host_allocator type ( solver_t ) :: solver #ifdef CUDA type ( cuda_backend_t ), target :: cuda_backend type ( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs , devnum #else type ( omp_backend_t ), target :: omp_backend #endif type ( allocator_t ), target :: omp_allocator real ( dp ) :: t_start , t_end character ( len = 200 ) :: input_file character ( len = 20 ) :: BC_x ( 2 ), BC_y ( 2 ), BC_z ( 2 ) integer , dimension ( 3 ) :: dims_global integer , dimension ( 3 ) :: nproc_dir = 0 real ( dp ), dimension ( 3 ) :: L_global integer :: nrank , nproc , ierr namelist / domain_params / L_global , dims_global , nproc_dir , BC_x , BC_y , BC_z call MPI_Init ( ierr ) call MPI_Comm_rank ( MPI_COMM_WORLD , nrank , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , nproc , ierr ) if ( nrank == 0 ) print * , 'Parallel run with' , nproc , 'ranks' #ifdef CUDA ierr = cudaGetDeviceCount ( ndevs ) ierr = cudaSetDevice ( mod ( nrank , ndevs )) ! round-robin ierr = cudaGetDevice ( devnum ) #endif if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , input_file ) open ( 100 , file = input_file ) read ( 100 , nml = domain_params ) close ( 100 ) else error stop 'Input file is not provided.' end if if ( product ( nproc_dir ) /= nproc ) then if ( nrank == 0 ) print * , 'nproc_dir specified in the input file does & &not match the total number of ranks, falling & &back to a 1D decomposition along Z-dir instead.' nproc_dir = [ 1 , 1 , nproc ] end if mesh = mesh_t ( dims_global , nproc_dir , L_global , BC_x , BC_y , BC_z ) #ifdef CUDA cuda_allocator = cuda_allocator_t ( mesh , SZ ) allocator => cuda_allocator if ( nrank == 0 ) print * , 'CUDA allocator instantiated' omp_allocator = allocator_t ( mesh , SZ ) host_allocator => omp_allocator cuda_backend = cuda_backend_t ( mesh , allocator ) backend => cuda_backend if ( nrank == 0 ) print * , 'CUDA backend instantiated' #else omp_allocator = allocator_t ( mesh , SZ ) allocator => omp_allocator host_allocator => omp_allocator if ( nrank == 0 ) print * , 'OpenMP allocator instantiated' omp_backend = omp_backend_t ( mesh , allocator ) backend => omp_backend if ( nrank == 0 ) print * , 'OpenMP backend instantiated' #endif solver = solver_t ( backend , mesh , host_allocator ) if ( nrank == 0 ) print * , 'solver instantiated' call cpu_time ( t_start ) call solver % run () call cpu_time ( t_end ) if ( nrank == 0 ) print * , 'Time: ' , t_end - t_start call MPI_Finalize ( ierr ) end program xcompact","tags":"","loc":"sourcefile/xcompact.f90.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_common implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( dp ), parameter :: pi = 4 * atan ( 1.0_dp ) integer , parameter :: RDR_X2Y = 12 , RDR_X2Z = 13 , RDR_Y2X = 21 , & RDR_Y2Z = 23 , RDR_Z2X = 31 , RDR_Z2Y = 32 , & RDR_C2X = 41 , RDR_C2Y = 42 , RDR_C2Z = 43 , & RDR_X2C = 14 , RDR_Y2C = 24 , RDR_Z2C = 34 integer , parameter :: DIR_X = 1 , DIR_Y = 2 , DIR_Z = 3 , DIR_C = 4 integer , parameter :: POISSON_SOLVER_FFT = 0 , POISSON_SOLVER_CG = 1 integer , parameter :: VERT = 1 , & ! Vertex centered data CELL = 2 , & ! Cell centered data X_FACE = 11 , & ! Data on faces normal to X Y_FACE = 12 , & ! Data on faces normal to Y Z_FACE = 13 , & ! Data on faces normal to Z X_EDGE = 101 , & ! Data on edges along X Y_EDGE = 102 , & ! Data on edges along Y Z_EDGE = 103 , & ! Data on edges along Z none = - 1 ! The location of data isn't specified integer , parameter :: BC_PERIODIC = 0 , BC_NEUMANN = 1 , BC_DIRICHLET = 2 integer , protected :: & rdr_map ( 4 , 4 ) = reshape ([ 0 , RDR_Y2X , RDR_Z2X , RDR_C2X , & RDR_X2Y , 0 , RDR_Z2Y , RDR_C2Y , & RDR_X2Z , RDR_Y2Z , 0 , RDR_C2Z , & RDR_X2C , RDR_Y2C , RDR_Z2C , 0 ], shape = [ 4 , 4 ]) contains pure subroutine get_dirs_from_rdr ( dir_from , dir_to , rdr_dir ) integer , intent ( out ) :: dir_from , dir_to integer , intent ( in ) :: rdr_dir integer , dimension ( 2 ) :: dirs dirs = findloc ( rdr_map , rdr_dir ) dir_from = dirs ( 1 ) dir_to = dirs ( 2 ) end subroutine pure integer function get_rdr_from_dirs ( dir_from , dir_to ) result ( rdr_dir ) !! Returns RDR_?2? value based on two direction inputs integer , intent ( in ) :: dir_from , dir_to rdr_dir = rdr_map ( dir_from , dir_to ) end function get_rdr_from_dirs end module m_common","tags":"","loc":"sourcefile/common.f90~2.html"},{"title":"common.f90 – x3d2","text":"Source Code module m_omp_common implicit none integer , parameter :: SZ = 16 end module m_omp_common","tags":"","loc":"sourcefile/common.f90~3.html"},{"title":"time_integrator.f90 – x3d2","text":"Source Code module m_time_integrator use m_allocator , only : allocator_t , field_t , flist_t use m_base_backend , only : base_backend_t use m_common , only : dp , DIR_X implicit none private adams_bashforth , runge_kutta type :: time_intg_t integer :: method , istep , istage , order , nstep , nstage , nvars , nolds real ( dp ) :: coeffs ( 4 , 4 ) real ( dp ) :: rk_b ( 4 , 4 ) real ( dp ) :: rk_a ( 3 , 3 , 4 ) character ( len = 3 ) :: sname type ( flist_t ), allocatable :: olds (:, :) type ( flist_t ), allocatable :: curr (:) type ( flist_t ), allocatable :: deriv (:) class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator procedure ( stepper_func ), pointer :: stepper => null () contains procedure :: finalize procedure :: step procedure :: runge_kutta procedure :: adams_bashforth end type time_intg_t interface time_intg_t module procedure init end interface time_intg_t abstract interface subroutine stepper_func ( self , dt ) import :: time_intg_t import :: dp implicit none class ( time_intg_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: dt end subroutine stepper_func end interface contains subroutine finalize ( self ) implicit none !type(time_intg_t), intent(inout) :: self class ( time_intg_t ), intent ( inout ) :: self integer :: i , j ! Release all the storage for old timesteps do i = 1 , self % nvars do j = 1 , self % nolds call self % allocator % release_block ( self % olds ( i , j )% ptr ) end do end do ! deallocate memory deallocate ( self % olds ) deallocate ( self % curr ) deallocate ( self % deriv ) print * , self % sname , ' time integrator deallocated' end subroutine finalize function init ( backend , allocator , method , nvars ) implicit none type ( time_intg_t ) :: init class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator character ( 3 ), intent ( in ) :: method integer , intent ( in ), optional :: nvars integer :: i , j , stat ! initialize Runge-Kutta coefficients ! rk1 init % rk_a (:, 1 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 3 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 1 ) = [ 1._dp , 0._dp , 0._dp , 0._dp ] ! rk2 init % rk_a (:, 1 , 2 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 2 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 3 , 2 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 2 ) = [ 0._dp , 1._dp , 0._dp , 0._dp ] ! rk3 init % rk_a (:, 1 , 3 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 3 ) = [ 0.0_dp , 3._dp / 4._dp , 0._dp ] init % rk_a (:, 3 , 3 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 3 ) = & [ 2._dp / 9.0_dp , 1._dp / 3._dp , 4._dp / 9._dp , 0._dp ] ! rk4 init % rk_a (:, 1 , 4 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 4 ) = [ 0._dp , 0.5_dp , 0._dp ] init % rk_a (:, 3 , 4 ) = [ 0._dp , 0._dp , 1._dp ] init % rk_b (:, 4 ) = & [ 1._dp / 6._dp , 1._dp / 3._dp , 1._dp / 3._dp , 1._dp / 6._dp ] ! initialize Adams-Bashforth coefficients ! ab1 init % coeffs (:, 1 ) = [ 1._dp , 0._dp , 0._dp , 0._dp ] ! ab2 init % coeffs (:, 2 ) = [ 1.5_dp , - 0.5_dp , 0._dp , 0._dp ] ! ab3 init % coeffs (:, 3 ) = & [ 2 3._dp / 1 2._dp , - 4._dp / 3._dp , 5._dp / 1 2._dp , 0._dp ] ! ab4 init % coeffs (:, 4 ) = & [ 5 5._dp / 2 4._dp , - 5 9._dp / 2 4._dp , 3 7._dp / 2 4._dp , - 3._dp / 8._dp ] ! set variables init % backend => backend init % allocator => allocator init % sname = method if ( init % sname ( 1 : 2 ) == 'AB' ) then read ( init % sname ( 3 : 3 ), * , iostat = stat ) init % order if ( stat /= 0 ) error stop 'Error reading AB integration order' if ( init % order >= 5 ) error stop 'Integration order >4 is not supported' init % nstep = init % order init % nstage = 1 init % nolds = init % nstep - 1 init % stepper => adams_bashforth else if ( init % sname ( 1 : 2 ) == 'RK' ) then read ( init % sname ( 3 : 3 ), * , iostat = stat ) init % order if ( stat /= 0 ) error stop 'Error reading RK integration order' if ( init % order >= 5 ) error stop 'Integration order >4 is not supported' init % nstep = 1 init % nstage = init % order init % nolds = init % nstage init % stepper => runge_kutta else print * , 'Integration method ' // init % sname // ' is not defined' error stop end if if ( present ( nvars )) then init % nvars = nvars else init % nvars = 3 end if init % istep = 1 init % istage = 1 ! allocate memory allocate ( init % olds ( init % nvars , init % nolds )) allocate ( init % curr ( init % nvars )) allocate ( init % deriv ( init % nvars )) ! Request all the storage for old timesteps do i = 1 , init % nvars do j = 1 , init % nolds init % olds ( i , j )% ptr => allocator % get_block ( DIR_X ) end do end do end function init subroutine step ( self , u , v , w , du , dv , dw , dt ) implicit none class ( time_intg_t ), intent ( inout ) :: self class ( field_t ), target , intent ( inout ) :: u , v , w class ( field_t ), target , intent ( in ) :: du , dv , dw real ( dp ), intent ( in ) :: dt ! assign pointer to variables self % curr ( 1 )% ptr => u self % curr ( 2 )% ptr => v self % curr ( 3 )% ptr => w ! assign pointer to variables self % deriv ( 1 )% ptr => du self % deriv ( 2 )% ptr => dv self % deriv ( 3 )% ptr => dw call self % stepper ( dt ) end subroutine step subroutine runge_kutta ( self , dt ) implicit none class ( time_intg_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: dt integer :: i , j ! update solution if ( self % istage == self % nstage ) then do i = 1 , self % nvars ! update step solution from stage derivative if ( self % nstage > 1 ) then call self % backend % vecadd ( 1.0_dp , self % olds ( i , 1 )% ptr , 0._dp , & self % curr ( i )% ptr ) end if do j = 1 , self % nstage - 1 call self % backend % vecadd ( self % rk_b ( j , self % nstage ) * dt , & self % olds ( i , j + 1 )% ptr , & 1._dp , self % curr ( i )% ptr ) end do call self % backend % vecadd ( self % rk_b ( self % nstage , self % nstage ) * dt , & self % deriv ( i )% ptr , & 1._dp , self % curr ( i )% ptr ) end do ! reset stage counter self % istage = 1 else do i = 1 , self % nvars ! save step initial condition if ( self % istage == 1 ) then call self % backend % vecadd ( 1.0_dp , self % curr ( i )% ptr , 0._dp , & self % olds ( i , 1 )% ptr ) end if ! save stage derivative call self % backend % vecadd ( 1.0_dp , self % deriv ( i )% ptr , 0._dp , & self % olds ( i , self % istage + 1 )% ptr ) ! update stage solution if ( self % istage > 1 ) then call self % backend % vecadd ( 1.0_dp , self % olds ( i , 1 )% ptr , 0._dp , & self % curr ( i )% ptr ) end if do j = 1 , self % istage call self % backend % vecadd ( self % rk_a ( j , self % istage , self % nstage ) * dt , & self % olds ( i , j + 1 )% ptr , & 1._dp , self % curr ( i )% ptr ) end do end do ! increment stage counter self % istage = self % istage + 1 end if end subroutine runge_kutta subroutine adams_bashforth ( self , dt ) implicit none class ( time_intg_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: dt integer :: i , j integer :: nstep nstep = min ( self % istep , self % nstep ) do i = 1 , self % nvars ! update solution call self % backend % vecadd ( self % coeffs ( 1 , nstep ) * dt , & self % deriv ( i )% ptr , & 1._dp , self % curr ( i )% ptr ) do j = 2 , nstep call self % backend % vecadd ( self % coeffs ( j , nstep ) * dt , & self % olds ( i , j - 1 )% ptr , & 1._dp , self % curr ( i )% ptr ) end do ! rotate pointers if ( nstep < self % nstep ) then ! for startup if ( self % istep > 1 ) then call rotate ( self % olds ( i , :), nstep ) end if else ! after startup if ( self % nstep > 2 ) then call rotate ( self % olds ( i , :), nstep - 1 ) end if end if ! update olds(1) with new derivative if ( self % nstep > 1 ) then call self % backend % vecadd ( 1.0_dp , self % deriv ( i )% ptr , 0._dp , & self % olds ( i , 1 )% ptr ) end if end do ! increment step counter self % istep = self % istep + 1 end subroutine adams_bashforth subroutine rotate ( sol , n ) implicit none type ( flist_t ), intent ( inout ) :: sol (:) integer , intent ( in ) :: n integer :: i class ( field_t ), pointer :: ptr ! rotate pointer ptr => sol ( n )% ptr do i = n , 2 , - 1 sol ( i )% ptr => sol ( i - 1 )% ptr end do sol ( 1 )% ptr => ptr end subroutine rotate end module m_time_integrator","tags":"","loc":"sourcefile/time_integrator.f90.html"},{"title":"reorder.f90 – x3d2","text":"Source Code module m_cuda_kernels_reorder use cudafor use m_common , only : dp use m_cuda_common , only : SZ contains attributes ( global ) subroutine reorder_c2x ( u_x , u_c , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_c integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_c ( i + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) call syncthreads () ! copy into output array from shared u_x ( i , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) = tile ( j , i ) end subroutine reorder_c2x attributes ( global ) subroutine reorder_x2c ( u_c , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_c real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x ( i , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) call syncthreads () ! copy into output array from shared u_c ( i + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) = tile ( j , i ) end subroutine reorder_x2c attributes ( global ) subroutine reorder_x2y ( u_y , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x ( i , j + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) call syncthreads () ! copy into output array from shared u_y ( i , j + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = tile ( j , i ) end subroutine reorder_x2y attributes ( global ) subroutine reorder_x2z ( u_z , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x ! Data access pattern for reordering between x and z is quite nice ! thus we don't need to use shared memory for this operation. do j = 1 , nz u_z ( i , j , b_i + ( b_j - 1 ) * nx ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) end do end subroutine reorder_x2z attributes ( global ) subroutine reorder_y2x ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_y2x attributes ( global ) subroutine reorder_y2z ( u_z , u_y , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) call syncthreads () ! copy into output array from shared u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) = tile ( j , i ) end subroutine reorder_y2z attributes ( global ) subroutine reorder_z2x ( u_x , u_z , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine reorder_z2x attributes ( global ) subroutine reorder_z2y ( u_y , u_z , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) call syncthreads () ! copy into output array from shared u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) = tile ( j , i ) end subroutine reorder_z2y attributes ( global ) subroutine sum_yintox ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_k ) + nz * ( b_i - 1 )) call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) + tile ( j , i ) end subroutine sum_yintox attributes ( global ) subroutine sum_zintox ( u_x , u_z , nz ) implicit none ! Arguments real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) & + u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine sum_zintox attributes ( global ) subroutine axpby ( n , alpha , x , beta , y ) implicit none integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: alpha , beta real ( dp ), device , intent ( in ), dimension (:, :, :) :: x real ( dp ), device , intent ( inout ), dimension (:, :, :) :: y integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n y ( i , j , b ) = alpha * x ( i , j , b ) + beta * y ( i , j , b ) end do end subroutine axpby attributes ( global ) subroutine scalar_product ( s , x , y , n ) implicit none real ( dp ), device , intent ( inout ) :: s real ( dp ), device , intent ( in ), dimension (:, :, :) :: x , y integer , value , intent ( in ) :: n real ( dp ) :: s_pncl !! pencil sum integer :: i , j , b , ierr i = threadIdx % x b = blockIdx % x s_pncl = 0._dp do j = 1 , n s_pncl = s_pncl + x ( i , j , b ) * y ( i , j , b ) end do ierr = atomicadd ( s , s_pncl ) end subroutine scalar_product attributes ( global ) subroutine buffer_copy ( u_send_s , u_send_e , u , n , n_halo ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_send_s , u_send_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u integer , value , intent ( in ) :: n , n_halo integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n_halo u_send_s ( i , j , b ) = u ( i , j , b ) u_send_e ( i , j , b ) = u ( i , n - n_halo + j , b ) end do end subroutine buffer_copy end module m_cuda_kernels_reorder","tags":"","loc":"sourcefile/reorder.f90.html"},{"title":"field.f90 – x3d2","text":"Source Code module m_field use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C type :: field_t !! Memory block type holding both a data field and a pointer !! to the next block.  The `field_t` type also holds a integer !! `refcount` that counts the number of references to this !! field.  User code is currently responsible for incrementing !! the reference count. class ( field_t ), pointer :: next real ( dp ), pointer , private :: p_data (:) real ( dp ), pointer , contiguous :: data (:, :, :) integer :: dir integer :: data_loc integer :: refcount = 0 integer :: id !! An integer identifying the memory block. contains procedure :: set_shape procedure :: set_data_loc end type field_t interface field_t module procedure field_init end interface field_t contains subroutine set_data_loc ( self , data_loc ) class ( field_t ) :: self integer , intent ( in ) :: data_loc self % data_loc = data_loc end subroutine subroutine set_shape ( self , dims ) implicit none class ( field_t ) :: self integer , intent ( in ) :: dims ( 3 ) self % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 )) => self % p_data end subroutine set_shape function field_init ( ngrid , next , id ) result ( f ) integer , intent ( in ) :: ngrid , id type ( field_t ), pointer , intent ( in ) :: next type ( field_t ) :: f allocate ( f % p_data ( ngrid )) f % refcount = 0 f % next => next f % id = id end function field_init end module m_field","tags":"","loc":"sourcefile/field.f90.html"},{"title":"allocator.f90 – x3d2","text":"Source Code module m_cuda_allocator use m_allocator , only : allocator_t , field_t use m_common , only : dp use m_field , only : field_t use m_mesh , only : mesh_t implicit none type , extends ( allocator_t ) :: cuda_allocator_t contains procedure :: create_block => create_cuda_block end type cuda_allocator_t interface cuda_allocator_t module procedure cuda_allocator_init end interface cuda_allocator_t type , extends ( field_t ) :: cuda_field_t real ( dp ), device , pointer , private :: p_data_d (:) real ( dp ), device , pointer , contiguous :: data_d (:, :, :) contains procedure :: set_shape => set_shape_cuda end type cuda_field_t interface cuda_field_t module procedure cuda_field_init end interface cuda_field_t contains function cuda_field_init ( ngrid , next , id ) result ( f ) integer , intent ( in ) :: ngrid , id type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ) :: f allocate ( f % p_data_d ( ngrid )) f % refcount = 0 f % next => next f % id = id end function cuda_field_init subroutine set_shape_cuda ( self , dims ) implicit none class ( cuda_field_t ) :: self integer , intent ( in ) :: dims ( 3 ) self % data_d ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 )) => self % p_data_d end subroutine set_shape_cuda function cuda_allocator_init ( mesh , sz ) result ( allocator ) class ( mesh_t ), intent ( inout ) :: mesh integer , intent ( in ) :: sz type ( cuda_allocator_t ) :: allocator allocator % allocator_t = allocator_t ( mesh , sz ) end function cuda_allocator_init function create_cuda_block ( self , next ) result ( ptr ) class ( cuda_allocator_t ), intent ( inout ) :: self type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ), pointer :: newblock class ( field_t ), pointer :: ptr allocate ( newblock ) self % next_id = self % next_id + 1 newblock = cuda_field_t ( self % ngrid , next , id = self % next_id ) ptr => newblock end function create_cuda_block end module m_cuda_allocator","tags":"","loc":"sourcefile/allocator.f90.html"},{"title":"sendrecv.f90 – x3d2","text":"Source Code module m_omp_sendrecv use mpi use m_common , only : dp implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields end module m_omp_sendrecv","tags":"","loc":"sourcefile/sendrecv.f90.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_omp_backend use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_ordering , only : get_index_reordering use m_common , only : dp , get_dirs_from_rdr , VERT , DIR_X , DIR_Y , DIR_Z , DIR_C use m_tdsops , only : dirps_t , tdsops_t , get_tds_n use m_omp_exec_dist , only : exec_dist_tds_compact , exec_dist_transeq_compact use m_omp_sendrecv , only : sendrecv_fields use m_omp_common , only : SZ use m_omp_poisson_fft , only : omp_poisson_fft_t use m_mesh , only : mesh_t implicit none private :: transeq_halo_exchange , transeq_dist_component type , extends ( base_backend_t ) :: omp_backend_t !character(len=*), parameter :: name = 'omp' integer :: MPI_FP_PREC = dp real ( dp ), allocatable , dimension (:, :, :) :: & u_recv_s , u_recv_e , u_send_s , u_send_e , & v_recv_s , v_recv_e , v_send_s , v_send_e , & w_recv_s , w_recv_e , w_send_s , w_send_e , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e contains procedure :: alloc_tdsops => alloc_omp_tdsops procedure :: transeq_x => transeq_x_omp procedure :: transeq_y => transeq_y_omp procedure :: transeq_z => transeq_z_omp procedure :: tds_solve => tds_solve_omp procedure :: reorder => reorder_omp procedure :: sum_yintox => sum_yintox_omp procedure :: sum_zintox => sum_zintox_omp procedure :: vecadd => vecadd_omp procedure :: scalar_product => scalar_product_omp procedure :: copy_data_to_f => copy_data_to_f_omp procedure :: copy_f_to_data => copy_f_to_data_omp procedure :: init_poisson_fft => init_omp_poisson_fft procedure :: transeq_omp_dist end type omp_backend_t interface omp_backend_t module procedure init end interface omp_backend_t contains function init ( mesh , allocator ) result ( backend ) implicit none class ( mesh_t ), target , intent ( inout ) :: mesh class ( allocator_t ), target , intent ( inout ) :: allocator type ( omp_backend_t ) :: backend integer :: n_halo , n_groups call backend % base_init () select type ( allocator ) type is ( allocator_t ) ! class level access to the allocator backend % allocator => allocator end select n_halo = 4 backend % mesh => mesh n_groups = maxval ([ backend % mesh % get_n_groups ( DIR_X ), & backend % mesh % get_n_groups ( DIR_Y ), & backend % mesh % get_n_groups ( DIR_Z )]) allocate ( backend % u_send_s ( SZ , n_halo , n_groups )) allocate ( backend % u_send_e ( SZ , n_halo , n_groups )) allocate ( backend % u_recv_s ( SZ , n_halo , n_groups )) allocate ( backend % u_recv_e ( SZ , n_halo , n_groups )) allocate ( backend % v_send_s ( SZ , n_halo , n_groups )) allocate ( backend % v_send_e ( SZ , n_halo , n_groups )) allocate ( backend % v_recv_s ( SZ , n_halo , n_groups )) allocate ( backend % v_recv_e ( SZ , n_halo , n_groups )) allocate ( backend % w_send_s ( SZ , n_halo , n_groups )) allocate ( backend % w_send_e ( SZ , n_halo , n_groups )) allocate ( backend % w_recv_s ( SZ , n_halo , n_groups )) allocate ( backend % w_recv_e ( SZ , n_halo , n_groups )) allocate ( backend % du_send_s ( SZ , 1 , n_groups )) allocate ( backend % du_send_e ( SZ , 1 , n_groups )) allocate ( backend % du_recv_s ( SZ , 1 , n_groups )) allocate ( backend % du_recv_e ( SZ , 1 , n_groups )) allocate ( backend % dud_send_s ( SZ , 1 , n_groups )) allocate ( backend % dud_send_e ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_s ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_e ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_s ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_e ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_s ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_e ( SZ , 1 , n_groups )) end function init subroutine alloc_omp_tdsops ( & self , tdsops , dir , operation , scheme , & n_halo , from_to , bc_start , bc_end , sym , c_nu , nu0_nu & ) implicit none class ( omp_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: dir character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu integer :: tds_n real ( dp ) :: delta allocate ( tdsops_t :: tdsops ) select type ( tdsops ) type is ( tdsops_t ) tds_n = get_tds_n ( self % mesh , dir , from_to ) delta = self % mesh % geo % d ( dir ) tdsops = tdsops_t ( tds_n , delta , operation , scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) end select end subroutine alloc_omp_tdsops subroutine transeq_x_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call self % transeq_omp_dist ( du , dv , dw , u , v , w , dirps ) end subroutine transeq_x_omp subroutine transeq_y_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_omp_dist ( dv , du , dw , v , u , w , dirps ) end subroutine transeq_y_omp subroutine transeq_z_omp ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_omp_dist ( dw , du , dv , w , u , v , dirps ) end subroutine transeq_z_omp subroutine transeq_omp_dist ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call transeq_halo_exchange ( self , u , v , w , dirps % dir ) call transeq_dist_component ( self , du , u , u , & self % u_recv_s , self % u_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st , dirps % der1st_sym , & dirps % der2nd , dirps % dir ) call transeq_dist_component ( self , dv , v , u , & self % v_recv_s , self % v_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st_sym , dirps % der1st , & dirps % der2nd_sym , dirps % dir ) call transeq_dist_component ( self , dw , w , u , & self % w_recv_s , self % w_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st_sym , dirps % der1st , & dirps % der2nd_sym , dirps % dir ) end subroutine transeq_omp_dist subroutine transeq_halo_exchange ( self , u , v , w , dir ) class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: u , v , w integer , intent ( in ) :: dir integer :: n_halo , n , nproc_dir , pprev , pnext integer :: n_groups ! TODO: don't hardcode n_halo n_halo = 4 n_groups = self % mesh % get_n_groups ( dir ) n = self % mesh % get_n ( u ) nproc_dir = self % mesh % par % nproc_dir ( dir ) pprev = self % mesh % par % pprev ( dir ) pnext = self % mesh % par % pnext ( dir ) call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , & n , n_groups ) call copy_into_buffers ( self % v_send_s , self % v_send_e , v % data , & n , n_groups ) call copy_into_buffers ( self % w_send_s , self % w_send_e , w % data , & n , n_groups ) call sendrecv_fields ( self % u_recv_s , self % u_recv_e , & self % u_send_s , self % u_send_e , & SZ * n_halo * n_groups , & nproc_dir , pprev , pnext ) call sendrecv_fields ( self % v_recv_s , self % v_recv_e , & self % v_send_s , self % v_send_e , & SZ * n_halo * n_groups , & nproc_dir , pprev , pnext ) call sendrecv_fields ( self % w_recv_s , self % w_recv_e , & self % w_send_s , self % w_send_e , & SZ * n_halo * n_groups , & nproc_dir , pprev , pnext ) end subroutine transeq_halo_exchange subroutine transeq_dist_component ( self , rhs , u , conv , & u_recv_s , u_recv_e , & conv_recv_s , conv_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , dir ) !! Computes RHS_x&#94;u following: !! !! rhs_x&#94;u = -0.5*(conv*du/dx + d(u*conv)/dx) + nu*d2u/dx2 class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: rhs class ( field_t ), intent ( in ) :: u , conv real ( dp ), dimension (:, :, :), intent ( in ) :: u_recv_s , u_recv_e , & conv_recv_s , conv_recv_e class ( tdsops_t ), intent ( in ) :: tdsops_du class ( tdsops_t ), intent ( in ) :: tdsops_dud class ( tdsops_t ), intent ( in ) :: tdsops_d2u integer , intent ( in ) :: dir class ( field_t ), pointer :: du , d2u , dud du => self % allocator % get_block ( dir , VERT ) dud => self % allocator % get_block ( dir , VERT ) d2u => self % allocator % get_block ( dir , VERT ) call exec_dist_transeq_compact ( & rhs % data , du % data , dud % data , d2u % data , & self % du_send_s , self % du_send_e , self % du_recv_s , self % du_recv_e , & self % dud_send_s , self % dud_send_e , self % dud_recv_s , self % dud_recv_e , & self % d2u_send_s , self % d2u_send_e , self % d2u_recv_s , self % d2u_recv_e , & u % data , u_recv_s , u_recv_e , & conv % data , conv_recv_s , conv_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , self % nu , & self % mesh % par % nproc_dir ( dir ), self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir ), self % mesh % get_n_groups ( dir )) call self % allocator % release_block ( du ) call self % allocator % release_block ( dud ) call self % allocator % release_block ( d2u ) end subroutine transeq_dist_component subroutine tds_solve_omp ( self , du , u , dirps , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops ! Check if direction matches for both in/out fields and dirps if ( dirps % dir /= du % dir . or . u % dir /= du % dir ) then error stop 'DIR mismatch between fields and dirps in tds_solve.' end if call tds_solve_dist ( self , du , u , dirps , tdsops ) end subroutine tds_solve_omp subroutine tds_solve_dist ( self , du , u , dirps , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops integer :: n_halo , n_groups , dir ! TODO: don't hardcode n_halo n_halo = 4 dir = u % dir n_groups = self % mesh % get_n_groups ( u ) call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , & tdsops % tds_n , n_groups ) ! halo exchange call sendrecv_fields ( self % u_recv_s , self % u_recv_e , & self % u_send_s , self % u_send_e , & SZ * n_halo * n_groups , & self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir )) call exec_dist_tds_compact ( & du % data , u % data , self % u_recv_s , self % u_recv_e , & self % du_send_s , self % du_send_e , self % du_recv_s , self % du_recv_e , & tdsops , self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), self % mesh % par % pnext ( dir ), & n_groups ) end subroutine tds_solve_dist subroutine reorder_omp ( self , u_ , u , direction ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction integer , dimension ( 3 ) :: dims integer :: i , j , k integer :: out_i , out_j , out_k integer :: dir_from , dir_to dims = self % mesh % get_padded_dims ( u ) call get_dirs_from_rdr ( dir_from , dir_to , direction ) !$omp parallel do private(out_i, out_j, out_k) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) call get_index_reordering ( & out_i , out_j , out_k , i , j , k , dir_from , dir_to , self % mesh ) u_ % data ( out_i , out_j , out_k ) = u % data ( i , j , k ) end do end do end do !$omp end parallel do end subroutine reorder_omp subroutine sum_yintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ call sum_intox_omp ( self , u , u_ , DIR_Y ) end subroutine sum_yintox_omp subroutine sum_zintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ call sum_intox_omp ( self , u , u_ , DIR_Z ) end subroutine sum_zintox_omp subroutine sum_intox_omp ( self , u , u_ , dir_to ) class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ integer , intent ( in ) :: dir_to integer :: dir_from integer , dimension ( 3 ) :: dims integer :: i , j , k ! Working indices integer :: ii , jj , kk ! Transpose indices dir_from = DIR_X dims = self % mesh % get_padded_dims ( u ) !$omp parallel do private(i, ii, jj, kk) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) call get_index_reordering ( ii , jj , kk , i , j , k , & dir_from , dir_to , self % mesh ) u % data ( i , j , k ) = u % data ( i , j , k ) + u_ % data ( ii , jj , kk ) end do end do end do !$omp end parallel do end subroutine sum_intox_omp subroutine vecadd_omp ( self , a , x , b , y ) implicit none class ( omp_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y integer , dimension ( 3 ) :: dims integer :: i , j , k , ii integer :: nvec , remstart if ( x % dir /= y % dir ) then error stop \"Called vector add with incompatible fields\" end if dims = size ( x % data ) nvec = dims ( 1 ) / SZ remstart = nvec * SZ + 1 !$omp parallel do private(i, ii) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) ! Execute inner vectorised loops do ii = 1 , nvec !$omp simd do i = 1 , SZ y % data ( i + ( ii - 1 ) * SZ , j , k ) = & a * x % data ( i + ( ii - 1 ) * SZ , j , k ) + & b * y % data ( i + ( ii - 1 ) * SZ , j , k ) end do !$omp end simd end do ! Remainder loop do i = remstart , dims ( 1 ) y % data ( i , j , k ) = a * x % data ( i , j , k ) + b * y % data ( i , j , k ) end do end do end do !$omp end parallel do end subroutine vecadd_omp real ( dp ) function scalar_product_omp ( self , x , y ) result ( s ) use mpi use m_common , only : none , get_rdr_from_dirs implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y class ( field_t ), pointer :: x_ , y_ integer , dimension ( 3 ) :: dims integer :: i , j , k , ii integer :: nvec , remstart integer :: ierr if (( x % data_loc == none ) . or . ( y % data_loc == none )) then error stop \"You must set the data_loc before calling scalar product\" end if if ( x % data_loc /= y % data_loc ) then error stop \"Called scalar product with incompatible fields\" end if ! Reorient data into temporary DIR_C storage x_ => self % allocator % get_block ( DIR_C , x % data_loc ) call self % get_field_data ( x_ % data , x ) y_ => self % allocator % get_block ( DIR_C , y % data_loc ) call self % get_field_data ( y_ % data , y ) dims = self % mesh % get_field_dims ( x_ ) nvec = dims ( 1 ) / SZ remstart = nvec * SZ + 1 s = 0.0_dp !$omp parallel do reduction(+:s) private(i, ii) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) ! Execute inner vectorised loops do ii = 1 , nvec !$omp simd reduction(+:s) do i = 1 , SZ s = s + x_ % data ( i + ( ii - 1 ) * SZ , j , k ) * & y_ % data ( i + ( ii - 1 ) * SZ , j , k ) end do !$omp end simd end do ! Remainder loop do i = remstart , dims ( 1 ) s = s + x_ % data ( i , j , k ) * y_ % data ( i , j , k ) end do end do end do !$omp end parallel do ! Release temporary storage call self % allocator % release_block ( x_ ) call self % allocator % release_block ( y_ ) ! Reduce the result call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_DOUBLE_PRECISION , & MPI_SUM , MPI_COMM_WORLD , & ierr ) end function scalar_product_omp subroutine copy_into_buffers ( u_send_s , u_send_e , u , n , n_groups ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: u_send_s , u_send_e real ( dp ), dimension (:, :, :), intent ( in ) :: u integer , intent ( in ) :: n integer , intent ( in ) :: n_groups integer :: i , j , k integer :: n_halo = 4 !$omp parallel do do k = 1 , n_groups do j = 1 , n_halo !$omp simd do i = 1 , SZ u_send_s ( i , j , k ) = u ( i , j , k ) u_send_e ( i , j , k ) = u ( i , n - n_halo + j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine copy_into_buffers subroutine copy_data_to_f_omp ( self , f , data ) class ( omp_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: data f % data = data end subroutine copy_data_to_f_omp subroutine copy_f_to_data_omp ( self , data , f ) class ( omp_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f data = f % data end subroutine copy_f_to_data_omp subroutine init_omp_poisson_fft ( self , mesh , xdirps , ydirps , zdirps ) implicit none class ( omp_backend_t ) :: self class ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps allocate ( omp_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( omp_poisson_fft_t ) poisson_fft = omp_poisson_fft_t ( mesh , xdirps , ydirps , zdirps ) end select end subroutine init_omp_poisson_fft end module m_omp_backend","tags":"","loc":"sourcefile/backend.f90.html"},{"title":"ordering.f90 – x3d2","text":"Source Code module m_ordering use m_common , only : dp , get_dirs_from_rdr , DIR_X , DIR_Y , DIR_Z , DIR_C , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y use m_mesh , only : mesh_t implicit none interface get_index_reordering procedure get_index_reordering_rdr , get_index_reordering_dirs end interface contains !! !! \"Application storage\" stores spatial data with a directionality for better cache locality !!  This set of functions converts indices from this application storage (_dir) to cartesian indices (_ijk) !! pure subroutine get_index_ijk ( i , j , k , dir_i , dir_j , dir_k , dir , & SZ , nx_padded , ny_padded , nz_padded ) !! Get cartesian index from application storage directional one integer , intent ( out ) :: i , j , k ! cartesian indices integer , intent ( in ) :: dir_i , dir_j , dir_k ! application storage indices integer , intent ( in ) :: dir ! direction of the applicatino storage indices integer , intent ( in ) :: SZ , nx_padded , ny_padded , nz_padded ! dimensions of the block select case ( dir ) case ( DIR_X ) i = dir_j j = mod ( dir_k - 1 , ny_padded / SZ ) * SZ + dir_i k = 1 + ( dir_k - 1 ) / ( ny_padded / SZ ) case ( DIR_Y ) i = mod ( dir_k - 1 , nx_padded / SZ ) * SZ + dir_i j = dir_j k = 1 + ( dir_k - 1 ) / ( nx_padded / SZ ) case ( DIR_Z ) i = mod ( dir_k - 1 , nx_padded / SZ ) * SZ + dir_i j = 1 + ( dir_k - 1 ) / ( nx_padded / SZ ) k = dir_j case ( DIR_C ) i = dir_i j = dir_j k = dir_k end select end subroutine get_index_ijk pure subroutine get_index_dir ( dir_i , dir_j , dir_k , i , j , k , dir , & SZ , nx_padded , ny_padded , nz_padded ) !! Get application storage directional index from cartesian index integer , intent ( out ) :: dir_i , dir_j , dir_k ! application storage indices integer , intent ( in ) :: i , j , k ! cartesian indices integer , intent ( in ) :: dir ! direction of the application storage indices integer , intent ( in ) :: SZ , nx_padded , ny_padded , nz_padded ! dimensions of the block select case ( dir ) case ( DIR_X ) dir_i = mod ( j - 1 , SZ ) + 1 dir_j = i dir_k = ( ny_padded / SZ ) * ( k - 1 ) + 1 + ( j - 1 ) / SZ case ( DIR_Y ) dir_i = mod ( i - 1 , SZ ) + 1 dir_j = j dir_k = ( nx_padded / SZ ) * ( k - 1 ) + 1 + ( i - 1 ) / SZ case ( DIR_Z ) dir_i = mod ( i - 1 , SZ ) + 1 dir_j = k dir_k = ( nx_padded / SZ ) * ( j - 1 ) + 1 + ( i - 1 ) / SZ case ( DIR_C ) dir_i = i dir_j = j dir_k = k end select end subroutine get_index_dir pure subroutine get_index_reordering_dirs ( & out_i , out_j , out_k , in_i , in_j , in_k , dir_from , dir_to , mesh & ) !! Converts a set of application storage directional index to an other direction. !! The two directions are defined by the reorder_dir variable, RDR_X2Y will go from storage in X to Y etc. integer , intent ( out ) :: out_i , out_j , out_k ! new indices in the application storage integer , intent ( in ) :: in_i , in_j , in_k ! original indices integer , intent ( in ) :: dir_from , dir_to class ( mesh_t ), intent ( in ) :: mesh integer :: i , j , k ! Intermediary cartesian indices integer , dimension ( 3 ) :: dims_padded dims_padded = mesh % get_padded_dims ( DIR_C ) call get_index_ijk ( i , j , k , in_i , in_j , in_k , dir_from , mesh % get_sz (), & dims_padded ( 1 ), dims_padded ( 2 ), dims_padded ( 3 )) call get_index_dir ( out_i , out_j , out_k , i , j , k , dir_to , mesh % get_sz (), & dims_padded ( 1 ), dims_padded ( 2 ), dims_padded ( 3 )) end subroutine get_index_reordering_dirs pure subroutine get_index_reordering_rdr ( out_i , out_j , out_k , & in_i , in_j , in_k , reorder_dir , mesh ) integer , intent ( out ) :: out_i , out_j , out_k ! new indices in the application storage integer , intent ( in ) :: in_i , in_j , in_k ! original indices integer , intent ( in ) :: reorder_dir class ( mesh_t ), intent ( in ) :: mesh integer :: dir_from , dir_to call get_dirs_from_rdr ( dir_from , dir_to , reorder_dir ) call get_index_reordering ( out_i , out_j , out_k , in_i , in_j , in_k , & dir_from , dir_to , mesh ) end subroutine get_index_reordering_rdr end module m_ordering","tags":"","loc":"sourcefile/ordering.f90.html"},{"title":"solver.f90 – x3d2","text":"Source Code module m_solver use iso_fortran_env , only : stderr => error_unit use mpi use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y , & RDR_Z2C , RDR_C2Z , & DIR_X , DIR_Y , DIR_Z , DIR_C , VERT , CELL use m_tdsops , only : tdsops_t , dirps_t use m_time_integrator , only : time_intg_t use m_mesh , only : mesh_t implicit none type :: solver_t !! solver class defines the Incompact3D algorithm at a very high level. !! !! Procedures defined here that are part of the Incompact3D algorithm !! are: transeq, divergence, poisson, and gradient. !! !! The operations these high level procedures require are provided by !! the relavant backend implementations. !! !! transeq procedure obtains the derivations in x, y, and z directions !! using the transeq_x, transeq_y, and transeq_z operations provided by !! the backend. !! There are two different algorithms available for this operation, a !! distributed algorithm and the Thomas algorithm. At the solver class !! level it isn't known which algorithm will be executed, that is decided !! at run time and therefore backend implementations are responsible for !! executing the right subroutines. !! !! Allocator is responsible from giving us a field sized array when !! requested. For example, when the derivations in x direction are !! completed and we are ready for the y directional derivatives, we need !! three fields to reorder and store the velocities in y direction. Also, !! we need three more fields for storing the results, and the get_block !! method of the allocator is used to arrange all these memory !! assignments. Later, when a field is no more required, release_block !! method of the allocator can be used to make this field available !! for later use. real ( dp ) :: dt , nu integer :: n_iters , n_output integer :: ngrid class ( field_t ), pointer :: u , v , w class ( base_backend_t ), pointer :: backend class ( mesh_t ), pointer :: mesh type ( time_intg_t ) :: time_integrator type ( allocator_t ), pointer :: host_allocator type ( dirps_t ), pointer :: xdirps , ydirps , zdirps procedure ( poisson_solver ), pointer :: poisson => null () contains procedure :: transeq procedure :: divergence_v2p procedure :: gradient_p2v procedure :: curl procedure :: output procedure :: run end type solver_t abstract interface subroutine poisson_solver ( self , pressure , div_u ) import :: solver_t import :: field_t implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u end subroutine poisson_solver end interface interface solver_t module procedure init end interface solver_t contains function init ( backend , mesh , host_allocator ) result ( solver ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( solver_t ) :: solver class ( field_t ), pointer :: u_init , v_init , w_init character ( len = 200 ) :: input_file real ( dp ) :: Re , dt integer :: n_iters , n_output character ( 3 ) :: poisson_solver_type , time_intg character ( 30 ) :: der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme namelist / solver_params / Re , dt , n_iters , n_output , poisson_solver_type , & time_intg , der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme real ( dp ) :: x , y , z integer :: i , j , k integer , dimension ( 3 ) :: dims real ( dp ), dimension ( 3 ) :: xloc solver % backend => backend solver % mesh => mesh solver % host_allocator => host_allocator allocate ( solver % xdirps , solver % ydirps , solver % zdirps ) solver % xdirps % dir = DIR_X solver % ydirps % dir = DIR_Y solver % zdirps % dir = DIR_Z solver % u => solver % backend % allocator % get_block ( DIR_X , VERT ) solver % v => solver % backend % allocator % get_block ( DIR_X , VERT ) solver % w => solver % backend % allocator % get_block ( DIR_X , VERT ) ! set defaults poisson_solver_type = 'FFT' time_intg = 'AB3' der1st_scheme = 'compact6' ; der2nd_scheme = 'compact6' interpl_scheme = 'classic' ; stagder_scheme = 'compact6' if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , input_file ) open ( 100 , file = input_file ) read ( 100 , nml = solver_params ) close ( 100 ) else error stop 'Input file is not provided.' end if solver % time_integrator = time_intg_t ( solver % backend , & solver % backend % allocator , & time_intg ) if ( solver % mesh % par % is_root ()) then print * , time_intg // ' time integrator instantiated' end if solver % dt = dt solver % backend % nu = 1._dp / Re solver % n_iters = n_iters solver % n_output = n_output solver % ngrid = product ( solver % mesh % get_global_dims ( VERT )) dims = solver % mesh % get_dims ( VERT ) u_init => solver % host_allocator % get_block ( DIR_C ) v_init => solver % host_allocator % get_block ( DIR_C ) w_init => solver % host_allocator % get_block ( DIR_C ) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) xloc = solver % mesh % get_coordinates ( i , j , k ) x = xloc ( 1 ) y = xloc ( 2 ) z = xloc ( 3 ) u_init % data ( i , j , k ) = sin ( x ) * cos ( y ) * cos ( z ) v_init % data ( i , j , k ) = - cos ( x ) * sin ( y ) * cos ( z ) w_init % data ( i , j , k ) = 0 end do end do end do call solver % backend % set_field_data ( solver % u , u_init % data ) call solver % backend % set_field_data ( solver % v , v_init % data ) call solver % backend % set_field_data ( solver % w , w_init % data ) call solver % host_allocator % release_block ( u_init ) call solver % host_allocator % release_block ( v_init ) call solver % host_allocator % release_block ( w_init ) ! Allocate and set the tdsops call allocate_tdsops ( solver % xdirps , solver % backend , & der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme ) call allocate_tdsops ( solver % ydirps , solver % backend , & der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme ) call allocate_tdsops ( solver % zdirps , solver % backend , & der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme ) select case ( trim ( poisson_solver_type )) case ( 'FFT' ) if ( solver % mesh % par % is_root ()) print * , 'Poisson solver: FFT' call solver % backend % init_poisson_fft ( solver % mesh , solver % xdirps , & solver % ydirps , solver % zdirps ) solver % poisson => poisson_fft case ( 'CG' ) if ( solver % mesh % par % is_root ()) & print * , 'Poisson solver: CG, not yet implemented' solver % poisson => poisson_cg case default error stop 'poisson_solver_type is not valid. Use \"FFT\" or \"CG\".' end select end function init subroutine allocate_tdsops ( dirps , backend , der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme ) type ( dirps_t ), intent ( inout ) :: dirps class ( base_backend_t ), intent ( in ) :: backend character ( * ), intent ( in ) :: der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme call backend % alloc_tdsops ( dirps % der1st , dirps % dir , & 'first-deriv' , der1st_scheme ) call backend % alloc_tdsops ( dirps % der1st_sym , dirps % dir , & 'first-deriv' , der1st_scheme ) call backend % alloc_tdsops ( dirps % der2nd , dirps % dir , & 'second-deriv' , der2nd_scheme ) call backend % alloc_tdsops ( dirps % der2nd_sym , dirps % dir , & 'second-deriv' , der2nd_scheme ) call backend % alloc_tdsops ( dirps % interpl_v2p , dirps % dir , & 'interpolate' , interpl_scheme , from_to = 'v2p' ) call backend % alloc_tdsops ( dirps % interpl_p2v , dirps % dir , & 'interpolate' , interpl_scheme , from_to = 'p2v' ) call backend % alloc_tdsops ( dirps % stagder_v2p , dirps % dir , & 'stag-deriv' , stagder_scheme , from_to = 'v2p' ) call backend % alloc_tdsops ( dirps % stagder_p2v , dirps % dir , & 'stag-deriv' , stagder_scheme , from_to = 'p2v' ) end subroutine subroutine transeq ( self , du , dv , dw , u , v , w ) !! Skew-symmetric form of convection-diffusion terms in the !! incompressible Navier-Stokes momemtum equations, excluding !! pressure terms. !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: u_y , v_y , w_y , u_z , v_z , w_z , & du_y , dv_y , dw_y , du_z , dv_z , dw_z ! -1/2(nabla u curl u + u nabla u) + nu nablasq u ! call derivatives in x direction. Based on the run time arguments this ! executes a distributed algorithm or the Thomas algorithm. call self % backend % transeq_x ( du , dv , dw , u , v , w , self % xdirps ) ! request fields from the allocator u_y => self % backend % allocator % get_block ( DIR_Y , VERT ) v_y => self % backend % allocator % get_block ( DIR_Y , VERT ) w_y => self % backend % allocator % get_block ( DIR_Y , VERT ) du_y => self % backend % allocator % get_block ( DIR_Y ) dv_y => self % backend % allocator % get_block ( DIR_Y ) dw_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % reorder ( v_y , v , RDR_X2Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % transeq_y ( du_y , dv_y , dw_y , u_y , v_y , w_y , self % ydirps ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) call self % backend % sum_yintox ( du , du_y ) call self % backend % sum_yintox ( dv , dv_y ) call self % backend % sum_yintox ( dw , dw_y ) call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block ( DIR_Z , VERT ) v_z => self % backend % allocator % get_block ( DIR_Z , VERT ) w_z => self % backend % allocator % get_block ( DIR_Z , VERT ) du_z => self % backend % allocator % get_block ( DIR_Z ) dv_z => self % backend % allocator % get_block ( DIR_Z ) dw_z => self % backend % allocator % get_block ( DIR_Z ) ! reorder from x to z call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % reorder ( w_z , w , RDR_X2Z ) ! get the derivatives in z call self % backend % transeq_z ( du_z , dv_z , dw_z , u_z , v_z , w_z , self % zdirps ) ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( w_z ) ! gather all the contributions into the x result array call self % backend % sum_zintox ( du , du_z ) call self % backend % sum_zintox ( dv , dv_z ) call self % backend % sum_zintox ( dw , dw_z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_z ) call self % backend % allocator % release_block ( dv_z ) call self % backend % allocator % release_block ( dw_z ) end subroutine transeq subroutine divergence_v2p ( self , div_u , u , v , w ) !! Divergence of a vector field (u, v, w). !! Inputs from velocity grid and outputs to pressure grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: div_u class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: du_x , dv_x , dw_x , & u_y , v_y , w_y , du_y , dv_y , dw_y , & u_z , w_z , dw_z du_x => self % backend % allocator % get_block ( DIR_X ) dv_x => self % backend % allocator % get_block ( DIR_X ) dw_x => self % backend % allocator % get_block ( DIR_X ) ! Staggared der for u field in x ! Interpolation for v field in x ! Interpolation for w field in x call self % backend % tds_solve ( du_x , u , self % xdirps , & self % xdirps % stagder_v2p ) call self % backend % tds_solve ( dv_x , v , self % xdirps , & self % xdirps % interpl_v2p ) call self % backend % tds_solve ( dw_x , w , self % xdirps , & self % xdirps % interpl_v2p ) ! request fields from the allocator u_y => self % backend % allocator % get_block ( DIR_Y , VERT ) v_y => self % backend % allocator % get_block ( DIR_Y , VERT ) w_y => self % backend % allocator % get_block ( DIR_Y , VERT ) ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , du_x , RDR_X2Y ) call self % backend % reorder ( v_y , dv_x , RDR_X2Y ) call self % backend % reorder ( w_y , dw_x , RDR_X2Y ) call self % backend % allocator % release_block ( du_x ) call self % backend % allocator % release_block ( dv_x ) call self % backend % allocator % release_block ( dw_x ) du_y => self % backend % allocator % get_block ( DIR_Y ) dv_y => self % backend % allocator % get_block ( DIR_Y ) dw_y => self % backend % allocator % get_block ( DIR_Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % tds_solve ( du_y , u_y , self % ydirps , & self % ydirps % interpl_v2p ) call self % backend % tds_solve ( dv_y , v_y , self % ydirps , & self % ydirps % stagder_v2p ) call self % backend % tds_solve ( dw_y , w_y , self % ydirps , & self % ydirps % interpl_v2p ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block ( DIR_Z , VERT ) w_z => self % backend % allocator % get_block ( DIR_Z , VERT ) ! du_y = dv_y + du_y call self % backend % vecadd ( 1._dp , dv_y , 1._dp , du_y ) ! reorder from y to z call self % backend % reorder ( u_z , du_y , RDR_Y2Z ) call self % backend % reorder ( w_z , dw_y , RDR_Y2Z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) dw_z => self % backend % allocator % get_block ( DIR_Z ) ! get the derivatives in z call self % backend % tds_solve ( div_u , u_z , self % zdirps , & self % zdirps % interpl_v2p ) call self % backend % tds_solve ( dw_z , w_z , self % zdirps , & self % zdirps % stagder_v2p ) ! div_u = div_u + dw_z call self % backend % vecadd ( 1._dp , dw_z , 1._dp , div_u ) ! div_u array is in z orientation ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( w_z ) call self % backend % allocator % release_block ( dw_z ) end subroutine divergence_v2p subroutine gradient_p2v ( self , dpdx , dpdy , dpdz , pressure ) !! Gradient of a scalar field 'pressure'. !! Inputs from pressure grid and outputs to velocity grid. implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: dpdx , dpdy , dpdz class ( field_t ), intent ( in ) :: pressure class ( field_t ), pointer :: p_sxy_z , dpdz_sxy_z , & p_sxy_y , dpdz_sxy_y , & p_sx_y , dpdy_sx_y , dpdz_sx_y , & p_sx_x , dpdy_sx_x , dpdz_sx_x p_sxy_z => self % backend % allocator % get_block ( DIR_Z ) dpdz_sxy_z => self % backend % allocator % get_block ( DIR_Z ) ! Staggared der for pressure field in z ! Interpolation for pressure field in z call self % backend % tds_solve ( p_sxy_z , pressure , self % zdirps , & self % zdirps % interpl_p2v ) call self % backend % tds_solve ( dpdz_sxy_z , pressure , self % zdirps , & self % zdirps % stagder_p2v ) ! request fields from the allocator p_sxy_y => self % backend % allocator % get_block ( DIR_Y ) dpdz_sxy_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from z orientation to y orientation call self % backend % reorder ( p_sxy_y , p_sxy_z , RDR_Z2Y ) call self % backend % reorder ( dpdz_sxy_y , dpdz_sxy_z , RDR_Z2Y ) call self % backend % allocator % release_block ( p_sxy_z ) call self % backend % allocator % release_block ( dpdz_sxy_z ) p_sx_y => self % backend % allocator % get_block ( DIR_Y ) dpdy_sx_y => self % backend % allocator % get_block ( DIR_Y ) dpdz_sx_y => self % backend % allocator % get_block ( DIR_Y ) ! similar to the z direction, obtain derivatives in y. call self % backend % tds_solve ( p_sx_y , p_sxy_y , self % ydirps , & self % ydirps % interpl_p2v ) call self % backend % tds_solve ( dpdy_sx_y , p_sxy_y , self % ydirps , & self % ydirps % stagder_p2v ) call self % backend % tds_solve ( dpdz_sx_y , dpdz_sxy_y , self % ydirps , & self % ydirps % interpl_p2v ) ! release memory call self % backend % allocator % release_block ( p_sxy_y ) call self % backend % allocator % release_block ( dpdz_sxy_y ) ! just like in y direction, get some fields for the x derivatives. p_sx_x => self % backend % allocator % get_block ( DIR_X ) dpdy_sx_x => self % backend % allocator % get_block ( DIR_X ) dpdz_sx_x => self % backend % allocator % get_block ( DIR_X ) ! reorder from y to x call self % backend % reorder ( p_sx_x , p_sx_y , RDR_Y2X ) call self % backend % reorder ( dpdy_sx_x , dpdy_sx_y , RDR_Y2X ) call self % backend % reorder ( dpdz_sx_x , dpdz_sx_y , RDR_Y2X ) ! release all the y directional fields. call self % backend % allocator % release_block ( p_sx_y ) call self % backend % allocator % release_block ( dpdy_sx_y ) call self % backend % allocator % release_block ( dpdz_sx_y ) ! get the derivatives in x call self % backend % tds_solve ( dpdx , p_sx_x , self % xdirps , & self % xdirps % stagder_p2v ) call self % backend % tds_solve ( dpdy , dpdy_sx_x , self % xdirps , & self % xdirps % interpl_p2v ) call self % backend % tds_solve ( dpdz , dpdz_sx_x , self % xdirps , & self % xdirps % interpl_p2v ) ! release temporary x fields call self % backend % allocator % release_block ( p_sx_x ) call self % backend % allocator % release_block ( dpdy_sx_x ) call self % backend % allocator % release_block ( dpdz_sx_x ) end subroutine gradient_p2v subroutine curl ( self , o_i_hat , o_j_hat , o_k_hat , u , v , w ) !! Curl of a vector field (u, v, w). !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self !> Vector components of the output vector field Omega class ( field_t ), intent ( inout ) :: o_i_hat , o_j_hat , o_k_hat class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: u_y , u_z , v_z , w_y , dwdy_y , dvdz_z , dvdz_x , & dudz_z , dudz_x , dudy_y , dudy_x ! omega_i_hat = dw/dy - dv/dz ! omega_j_hat = du/dz - dw/dx ! omega_k_hat = dv/dx - du/dy ! omega_i_hat ! dw/dy w_y => self % backend % allocator % get_block ( DIR_Y , VERT ) dwdy_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) call self % backend % tds_solve ( dwdy_y , w_y , self % ydirps , self % ydirps % der1st ) call self % backend % reorder ( o_i_hat , dwdy_y , RDR_Y2X ) call self % backend % allocator % release_block ( w_y ) call self % backend % allocator % release_block ( dwdy_y ) ! dv/dz v_z => self % backend % allocator % get_block ( DIR_Z ) dvdz_z => self % backend % allocator % get_block ( DIR_Z ) call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % tds_solve ( dvdz_z , v_z , self % zdirps , self % zdirps % der1st ) dvdz_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dvdz_x , dvdz_z , RDR_Z2X ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( dvdz_z ) ! omega_i_hat = dw/dy - dv/dz call self % backend % vecadd ( - 1._dp , dvdz_x , 1._dp , o_i_hat ) call self % backend % allocator % release_block ( dvdz_x ) ! omega_j_hat ! du/dz u_z => self % backend % allocator % get_block ( DIR_Z , VERT ) dudz_z => self % backend % allocator % get_block ( DIR_Z ) call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % tds_solve ( dudz_z , u_z , self % zdirps , self % zdirps % der1st ) dudz_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dudz_x , dudz_z , RDR_Z2X ) call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( dudz_z ) ! dw/dx call self % backend % tds_solve ( o_j_hat , w , self % xdirps , self % xdirps % der1st ) ! omega_j_hat = du/dz - dw/dx call self % backend % vecadd ( 1._dp , dudz_x , - 1._dp , o_j_hat ) call self % backend % allocator % release_block ( dudz_x ) ! omega_k_hat ! dv/dx call self % backend % tds_solve ( o_k_hat , v , self % xdirps , self % xdirps % der1st ) ! du/dy u_y => self % backend % allocator % get_block ( DIR_Y , VERT ) dudy_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % tds_solve ( dudy_y , u_y , self % ydirps , self % ydirps % der1st ) dudy_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dudy_x , dudy_y , RDR_Y2X ) call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( dudy_y ) ! omega_k_hat = dv/dx - du/dy call self % backend % vecadd ( - 1._dp , dudy_x , 1._dp , o_k_hat ) call self % backend % allocator % release_block ( dudy_x ) end subroutine curl subroutine poisson_fft ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u class ( field_t ), pointer :: p_temp ! reorder into 3D Cartesian data structure p_temp => self % backend % allocator % get_block ( DIR_C , CELL ) call self % backend % reorder ( p_temp , div_u , RDR_Z2C ) ! call forward FFT ! output array in spectral space is stored at poisson_fft class call self % backend % poisson_fft % fft_forward ( p_temp ) ! postprocess call self % backend % poisson_fft % fft_postprocess ! call backward FFT call self % backend % poisson_fft % fft_backward ( p_temp ) ! reorder back to our specialist data structure from 3D Cartesian call self % backend % reorder ( pressure , p_temp , RDR_C2Z ) call self % backend % allocator % release_block ( p_temp ) end subroutine poisson_fft subroutine poisson_cg ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u end subroutine poisson_cg subroutine output ( self , t ) implicit none class ( solver_t ), intent ( in ) :: self real ( dp ), intent ( in ) :: t class ( field_t ), pointer :: du , dv , dw , div_u class ( field_t ), pointer :: u_out real ( dp ) :: enstrophy , div_u_max , div_u_mean integer :: ierr if ( self % mesh % par % is_root ()) print * , 'time = ' , t du => self % backend % allocator % get_block ( DIR_X , VERT ) dv => self % backend % allocator % get_block ( DIR_X , VERT ) dw => self % backend % allocator % get_block ( DIR_X , VERT ) call self % curl ( du , dv , dw , self % u , self % v , self % w ) enstrophy = 0.5_dp * ( self % backend % scalar_product ( du , du ) & + self % backend % scalar_product ( dv , dv ) & + self % backend % scalar_product ( dw , dw )) / self % ngrid if ( self % mesh % par % is_root ()) print * , 'enstrophy:' , enstrophy call self % backend % allocator % release_block ( du ) call self % backend % allocator % release_block ( dv ) call self % backend % allocator % release_block ( dw ) div_u => self % backend % allocator % get_block ( DIR_Z ) call self % divergence_v2p ( div_u , self % u , self % v , self % w ) u_out => self % host_allocator % get_block ( DIR_C ) call self % backend % get_field_data ( u_out % data , div_u ) call self % backend % allocator % release_block ( div_u ) div_u_max = maxval ( abs ( u_out % data )) div_u_mean = sum ( abs ( u_out % data )) / self % ngrid call self % host_allocator % release_block ( u_out ) call MPI_Allreduce ( MPI_IN_PLACE , div_u_max , 1 , MPI_DOUBLE_PRECISION , & MPI_MAX , MPI_COMM_WORLD , ierr ) call MPI_Allreduce ( MPI_IN_PLACE , div_u_mean , 1 , MPI_DOUBLE_PRECISION , & MPI_SUM , MPI_COMM_WORLD , ierr ) if ( self % mesh % par % is_root ()) & print * , 'div u max mean:' , div_u_max , div_u_mean end subroutine output subroutine run ( self ) implicit none class ( solver_t ), intent ( inout ) :: self class ( field_t ), pointer :: du , dv , dw , div_u , pressure , dpdx , dpdy , dpdz class ( field_t ), pointer :: u_out , v_out , w_out real ( dp ) :: t integer :: i , j if ( self % mesh % par % is_root ()) print * , 'initial conditions' t = 0._dp call self % output ( t ) if ( self % mesh % par % is_root ()) print * , 'start run' do i = 1 , self % n_iters do j = 1 , self % time_integrator % nstage du => self % backend % allocator % get_block ( DIR_X ) dv => self % backend % allocator % get_block ( DIR_X ) dw => self % backend % allocator % get_block ( DIR_X ) call self % transeq ( du , dv , dw , self % u , self % v , self % w ) ! time integration call self % time_integrator % step ( self % u , self % v , self % w , & du , dv , dw , self % dt ) call self % backend % allocator % release_block ( du ) call self % backend % allocator % release_block ( dv ) call self % backend % allocator % release_block ( dw ) ! pressure div_u => self % backend % allocator % get_block ( DIR_Z ) call self % divergence_v2p ( div_u , self % u , self % v , self % w ) pressure => self % backend % allocator % get_block ( DIR_Z , CELL ) call self % poisson ( pressure , div_u ) call self % backend % allocator % release_block ( div_u ) dpdx => self % backend % allocator % get_block ( DIR_X ) dpdy => self % backend % allocator % get_block ( DIR_X ) dpdz => self % backend % allocator % get_block ( DIR_X ) call self % gradient_p2v ( dpdx , dpdy , dpdz , pressure ) call self % backend % allocator % release_block ( pressure ) ! velocity correction call self % backend % vecadd ( - 1._dp , dpdx , 1._dp , self % u ) call self % backend % vecadd ( - 1._dp , dpdy , 1._dp , self % v ) call self % backend % vecadd ( - 1._dp , dpdz , 1._dp , self % w ) call self % backend % allocator % release_block ( dpdx ) call self % backend % allocator % release_block ( dpdy ) call self % backend % allocator % release_block ( dpdz ) end do if ( mod ( i , self % n_output ) == 0 ) then t = i * self % dt call self % output ( t ) end if end do if ( self % mesh % par % is_root ()) print * , 'run end' ! Below is for demonstrating purpuses only, to be removed when we have ! proper I/O in place. u_out => self % host_allocator % get_block ( DIR_C ) v_out => self % host_allocator % get_block ( DIR_C ) w_out => self % host_allocator % get_block ( DIR_C ) call self % backend % get_field_data ( u_out % data , self % u ) call self % backend % get_field_data ( v_out % data , self % v ) call self % backend % get_field_data ( w_out % data , self % w ) if ( self % mesh % par % is_root ()) then print * , 'norms' , norm2 ( u_out % data ), norm2 ( v_out % data ), norm2 ( w_out % data ) end if call self % host_allocator % release_block ( u_out ) call self % host_allocator % release_block ( v_out ) call self % host_allocator % release_block ( w_out ) end subroutine run end module m_solver","tags":"","loc":"sourcefile/solver.f90.html"},{"title":"allocator.f90 – x3d2","text":"Source Code module m_allocator use iso_fortran_env , only : stderr => error_unit use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C , none , VERT use m_mesh , only : mesh_t use m_field , only : field_t implicit none type :: allocator_t !! An instance of type allocator_t is responsible for the !! maintenance of a linked list of instances of equal size !! [[m_allocator(module):field_t(type)]] objects: !! !! ``` !!       ---- ---- ----     ---- ---- ---- !! ...-->|id=1|data|next|-->|id=0|data|next|-->null() !!       ---- ---- ----     ---- ---- ---- !! ``` !! !! the last block's `next` pointer being non associated. !! !! User code can request access to a memory block by using the !! type bound procedure !! [[m_allocator(module):get_block(function)]].  If the list is !! not empty, a pointer to the first block on the list is !! returned and the block is detached from the list.  If the list !! is empty (i.e. all initially allocated blocks are currently !! referenced to) then a new block is allocated before a pointer !! to it is returned. !! !! In order to reuse memory it is important that user code !! release blocks when they are not needed anymore.  This is done !! by calling the type bound procedure !! [[m_allocator(module):release_block(subroutine)]].  The !! released block is then pushed in front of the block list. integer :: ngrid !> The id for the next allocated block.  This counter is !> incremented each time a new block is allocated. integer :: next_id = 0 !> The pointer to the first block on the list.  Non associated if !> the list is empty ! TODO: Rename first to head class ( mesh_t ), pointer :: mesh class ( field_t ), pointer :: first => null () contains procedure :: get_block procedure :: release_block procedure :: create_block procedure :: get_block_ids procedure :: destroy procedure :: compute_padded_dims end type allocator_t interface allocator_t module procedure allocator_init end interface allocator_t type :: flist_t class ( field_t ), pointer :: ptr end type flist_t contains function allocator_init ( mesh , sz ) result ( allocator ) type ( mesh_t ), target , intent ( inout ) :: mesh integer , intent ( in ) :: sz type ( allocator_t ) :: allocator allocator % mesh => mesh call allocator % compute_padded_dims ( sz ) allocator % ngrid = product ( allocator % mesh % get_padded_dims ( DIR_C )) end function allocator_init subroutine compute_padded_dims ( self , sz ) class ( allocator_t ), intent ( inout ) :: self integer , intent ( in ) :: sz integer , dimension ( 3 ) :: cdims integer :: nx , ny , nz , nx_padded , ny_padded , nz_padded cdims = self % mesh % get_dims ( VERT ) nx = cdims ( 1 ) ny = cdims ( 2 ) nz = cdims ( 3 ) ! Apply padding based on sz nx_padded = nx - 1 + mod ( - ( nx - 1 ), sz ) + sz ny_padded = ny - 1 + mod ( - ( ny - 1 ), sz ) + sz ! Current reorder functions do not require a padding in z-direction. nz_padded = nz cdims = [ nx_padded , ny_padded , nz_padded ] call self % mesh % set_sz ( sz ) call self % mesh % set_padded_dims ( cdims ) end subroutine function create_block ( self , next ) result ( ptr ) !! Allocate memory for a new block and return a pointer to a new !! [[m_allocator(module):field_t(type)]] object. class ( allocator_t ), intent ( inout ) :: self type ( field_t ), pointer , intent ( in ) :: next type ( field_t ), pointer :: newblock class ( field_t ), pointer :: ptr self % next_id = self % next_id + 1 allocate ( newblock ) newblock = field_t ( self % ngrid , next , id = self % next_id ) ptr => newblock end function create_block function get_block ( self , dir , data_loc ) result ( handle ) !! Return a pointer to the first available memory block, i.e. the !! current head of the block list.  If the list is empty, allocate !! a new block with [[m_allocator(module):create_block(function)]] !! first. !! !! Example !! ``` !! f%data => get_block() !! ``` class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle integer , intent ( in ) :: dir integer , intent ( in ), optional :: data_loc integer :: dims ( 3 ) ! If the list is empty, allocate a new block before returning a ! pointer to it. if (. not . associated ( self % first )) then ! Construct a field_t. This effectively allocates ! storage space. self % first => self % create_block ( next = self % first ) end if handle => self % first self % first => self % first % next ! 2nd block becomes head block handle % next => null () ! Detach ex-head block from the block list ! Store direction info in the field type. handle % dir = dir if ( present ( data_loc )) then handle % data_loc = data_loc else handle % data_loc = none end if ! Set dims based on direction dims = self % mesh % get_padded_dims ( dir ) ! Apply bounds remapping based on requested direction call handle % set_shape ( dims ) end function get_block subroutine release_block ( self , handle ) !! Release memory block pointed to by HANDLE to the block list. !! It is pushed to the front of the block list, in other words it !! is made the head block. class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle handle % next => self % first self % first => handle end subroutine release_block subroutine destroy ( self ) !! Go through the block list from head to tail, deallocating each !! memory block in turn.  Deallocation of a !! [[m_allocator(module):field_t(type)]] object automatically !! deallocates its internal allocatable !! [[field_t(type):data(variable)]] array. class ( allocator_t ), intent ( inout ) :: self type ( field_t ), pointer :: current do if (. not . associated ( self % first )) exit current => self % first self % first => self % first % next deallocate ( current ) self % next_id = self % next_id - 1 end do end subroutine destroy function get_block_ids ( self ) !! Utility function that returns a array made of the `id` of the !! block currently in the block list.  Return the array [0] if !! block list is empty. ! TODO: Block indices should start at 1 or return [-1] in case of ! empty block list. class ( allocator_t ), intent ( inout ) :: self integer , allocatable :: get_block_ids (:) class ( field_t ), pointer :: current integer :: i current => self % first if (. not . associated ( current )) then get_block_ids = [ 0 ] else i = current % id get_block_ids = [ current % id ] do if (. not . associated ( current % next )) exit i = current % next % id get_block_ids = [ get_block_ids , current % next % id ] current => current % next end do end if end function get_block_ids end module m_allocator","tags":"","loc":"sourcefile/allocator.f90~2.html"},{"title":"spectral_processing.f90 – x3d2","text":"Source Code module m_cuda_spectral use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine process_spectral_div_u ( & div_u , waves , nx_spec , ny_spec , y_sp_st , nx , ny , nz , & ax , bx , ay , by , az , bz & ) !! Post-processes the divergence of velocity in spectral space, including !! scaling w.r.t. grid size. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants complex ( dp ), device , intent ( in ), dimension (:, :, :) :: waves real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , ny_spec !> Offset in y direction in the permuted slabs in spectral space integer , value , intent ( in ) :: y_sp_st !> Grid size integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz real ( dp ) :: tmp_r , tmp_c , div_r , div_c j = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec if ( j <= ny_spec ) then do i = 1 , nx_spec ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / ( nx * ny * nz ) div_c = aimag ( div_u ( i , j , k )) / ( nx * ny * nz ) ix = i ; iy = j + y_sp_st ; iz = k ! post-process forward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) ! Solve Poisson tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if (( tmp_r < 1.e-16_dp ) . or . ( tmp_c < 1.e-16_dp )) then div_r = 0._dp ; div_c = 0._dp else div_r = - div_r / tmp_r div_c = - div_c / tmp_c end if ! post-process backward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = - tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = - tmp_c * bx ( ix ) + tmp_r * ax ( ix ) ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if end subroutine process_spectral_div_u end module m_cuda_spectral","tags":"","loc":"sourcefile/spectral_processing.f90.html"},{"title":"distributed.f90 – x3d2","text":"Source Code module m_omp_kernels_dist use omp_lib use m_common , only : dp use m_omp_common , only : SZ implicit none contains subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , coeffs_s , coeffs_e , coeffs , n , & ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du , send_u_s , send_u_e real ( dp ), intent ( in ), dimension (:, :) :: u , u_s , u_e real ( dp ), intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e ! start/end real ( dp ), intent ( in ), dimension (:) :: coeffs integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j !, b real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & temp_du , alpha , last_r ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) !$omp simd do i = 1 , SZ du ( i , 1 ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 ) du ( i , 1 ) = du ( i , 1 ) * faf ( 1 ) du ( i , 2 ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 ) du ( i , 2 ) = du ( i , 2 ) * faf ( 2 ) du ( i , 3 ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 ) du ( i , 3 ) = ffr ( 3 ) * ( du ( i , 3 ) - faf ( 3 ) * du ( i , 2 )) du ( i , 4 ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 ) du ( i , 4 ) = ffr ( 4 ) * ( du ( i , 4 ) - faf ( 4 ) * du ( i , 3 )) end do !$omp end simd ! alpha is always the same in the bulk region for us alpha = faf ( 5 ) do j = 5 , n - 4 !$omp simd do i = 1 , SZ temp_du = c_m4 * u ( i , j - 4 ) + c_m3 * u ( i , j - 3 ) & + c_m2 * u ( i , j - 2 ) + c_m1 * u ( i , j - 1 ) & + c_j * u ( i , j ) & + c_p1 * u ( i , j + 1 ) + c_p2 * u ( i , j + 2 ) & + c_p3 * u ( i , j + 3 ) + c_p4 * u ( i , j + 4 ) du ( i , j ) = ffr ( j ) * ( temp_du - alpha * du ( i , j - 1 )) end do !$omp end simd end do !$omp simd do i = 1 , SZ j = n - 3 du ( i , j ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 1 ) * u ( i , j ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n - 2 du ( i , j ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 2 ) * u ( i , j ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n - 1 du ( i , j ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 3 ) * u ( i , j ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n du ( i , j ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 4 ) * u ( i , j ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ send_u_e ( i , 1 ) = du ( i , n ) end do !$omp end simd ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 !$omp simd do i = 1 , SZ du ( i , j ) = du ( i , j ) - fbc ( j ) * du ( i , j + 1 ) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , 1 ) = last_r * ( du ( i , 1 ) - fbc ( 1 ) * du ( i , 2 )) send_u_s ( i , 1 ) = du ( i , 1 ) end do !$omp end simd end subroutine der_univ_dist subroutine der_univ_subs ( du , recv_u_s , recv_u_e , n , dist_sa , dist_sc ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du real ( dp ), intent ( in ), dimension (:, :) :: recv_u_s , recv_u_e real ( dp ), intent ( in ), dimension (:) :: dist_sa , dist_sc integer , intent ( in ) :: n ! Local variables integer :: i , j !, b real ( dp ) :: ur , bl , recp real ( dp ), dimension ( SZ ) :: du_s , du_e !$omp simd do i = 1 , SZ ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s ( i ) = recp * ( du ( i , 1 ) - bl * recv_u_s ( i , 1 )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e ( i ) = recp * ( du ( i , n ) - ur * recv_u_e ( i , 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ du ( i , 1 ) = du_s ( i ) end do !$omp end simd do j = 2 , n - 1 !$omp simd do i = 1 , SZ du ( i , j ) = ( du ( i , j ) - dist_sa ( j ) * du_s ( i ) - dist_sc ( j ) * du_e ( i )) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , n ) = du_e ( i ) end do !$omp end simd end subroutine der_univ_subs end module m_omp_kernels_dist","tags":"","loc":"sourcefile/distributed.f90.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_cuda_backend use iso_fortran_env , only : stderr => error_unit use cudafor use mpi use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y , & RDR_C2X , RDR_C2Y , RDR_C2Z , RDR_X2C , RDR_Y2C , RDR_Z2C , & DIR_X , DIR_Y , DIR_Z , DIR_C , VERT use m_mesh , only : mesh_t use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t , tdsops_t , get_tds_n use m_cuda_allocator , only : cuda_allocator_t , cuda_field_t use m_cuda_common , only : SZ use m_cuda_exec_dist , only : exec_dist_transeq_3fused , exec_dist_tds_compact use m_cuda_poisson_fft , only : cuda_poisson_fft_t use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t use m_cuda_kernels_dist , only : transeq_3fused_dist , transeq_3fused_subs use m_cuda_kernels_reorder , only : & reorder_x2y , reorder_x2z , reorder_y2x , reorder_y2z , reorder_z2x , & reorder_z2y , reorder_c2x , reorder_x2c , & sum_yintox , sum_zintox , scalar_product , axpby , buffer_copy implicit none private :: transeq_halo_exchange , transeq_dist_component type , extends ( base_backend_t ) :: cuda_backend_t !character(len=*), parameter :: name = 'cuda' integer :: MPI_FP_PREC = dp real ( dp ), device , allocatable , dimension (:, :, :) :: & u_recv_s_dev , u_recv_e_dev , u_send_s_dev , u_send_e_dev , & v_recv_s_dev , v_recv_e_dev , v_send_s_dev , v_send_e_dev , & w_recv_s_dev , w_recv_e_dev , w_send_s_dev , w_send_e_dev , & du_send_s_dev , du_send_e_dev , du_recv_s_dev , du_recv_e_dev , & dud_send_s_dev , dud_send_e_dev , dud_recv_s_dev , dud_recv_e_dev , & d2u_send_s_dev , d2u_send_e_dev , d2u_recv_s_dev , d2u_recv_e_dev type ( dim3 ) :: xblocks , xthreads , yblocks , ythreads , zblocks , zthreads contains procedure :: alloc_tdsops => alloc_cuda_tdsops procedure :: transeq_x => transeq_x_cuda procedure :: transeq_y => transeq_y_cuda procedure :: transeq_z => transeq_z_cuda procedure :: tds_solve => tds_solve_cuda procedure :: reorder => reorder_cuda procedure :: sum_yintox => sum_yintox_cuda procedure :: sum_zintox => sum_zintox_cuda procedure :: vecadd => vecadd_cuda procedure :: scalar_product => scalar_product_cuda procedure :: copy_data_to_f => copy_data_to_f_cuda procedure :: copy_f_to_data => copy_f_to_data_cuda procedure :: init_poisson_fft => init_cuda_poisson_fft procedure :: transeq_cuda_dist procedure :: transeq_cuda_thom procedure :: tds_solve_dist end type cuda_backend_t interface cuda_backend_t module procedure init end interface cuda_backend_t contains function init ( mesh , allocator ) result ( backend ) implicit none class ( mesh_t ), target , intent ( inout ) :: mesh class ( allocator_t ), target , intent ( inout ) :: allocator type ( cuda_backend_t ) :: backend type ( cuda_poisson_fft_t ) :: cuda_poisson_fft integer :: n_halo , n_groups call backend % base_init () select type ( allocator ) type is ( cuda_allocator_t ) ! class level access to the allocator backend % allocator => allocator end select backend % mesh => mesh backend % xthreads = dim3 ( SZ , 1 , 1 ) backend % xblocks = dim3 ( backend % mesh % get_n_groups ( DIR_X ), 1 , 1 ) backend % ythreads = dim3 ( SZ , 1 , 1 ) backend % yblocks = dim3 ( backend % mesh % get_n_groups ( DIR_Y ), 1 , 1 ) backend % zthreads = dim3 ( SZ , 1 , 1 ) backend % zblocks = dim3 ( backend % mesh % get_n_groups ( DIR_Z ), 1 , 1 ) n_halo = 4 ! Buffer size should be big enough for the largest MPI exchange. n_groups = maxval ([ backend % mesh % get_n_groups ( DIR_X ), & backend % mesh % get_n_groups ( DIR_Y ), & backend % mesh % get_n_groups ( DIR_Z )]) allocate ( backend % u_send_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % u_send_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % u_recv_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % u_recv_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % v_send_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % v_send_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % v_recv_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % v_recv_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % w_send_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % w_send_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % w_recv_s_dev ( SZ , n_halo , n_groups )) allocate ( backend % w_recv_e_dev ( SZ , n_halo , n_groups )) allocate ( backend % du_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % du_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % du_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % du_recv_e_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_e_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_e_dev ( SZ , 1 , n_groups )) end function init subroutine alloc_cuda_tdsops ( & self , tdsops , dir , operation , scheme , & n_halo , from_to , bc_start , bc_end , sym , c_nu , nu0_nu & ) implicit none class ( cuda_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: dir character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu integer :: tds_n real ( dp ) :: delta allocate ( cuda_tdsops_t :: tdsops ) select type ( tdsops ) type is ( cuda_tdsops_t ) tds_n = get_tds_n ( self % mesh , dir , from_to ) delta = self % mesh % geo % d ( dir ) tdsops = cuda_tdsops_t ( tds_n , delta , operation , & scheme , n_halo , from_to , & bc_start , bc_end , sym , c_nu , nu0_nu ) end select end subroutine alloc_cuda_tdsops subroutine transeq_x_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps call self % transeq_cuda_dist ( du , dv , dw , u , v , w , dirps , & self % xblocks , self % xthreads ) end subroutine transeq_x_cuda subroutine transeq_y_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_cuda_dist ( dv , du , dw , v , u , w , dirps , & self % yblocks , self % ythreads ) end subroutine transeq_y_cuda subroutine transeq_z_cuda ( self , du , dv , dw , u , v , w , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_cuda_dist ( dw , du , dv , w , u , v , dirps , & self % zblocks , self % zthreads ) end subroutine transeq_z_cuda subroutine transeq_cuda_dist ( self , du , dv , dw , u , v , w , dirps , & blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps type ( dim3 ), intent ( in ) :: blocks , threads real ( dp ), device , pointer , dimension (:, :, :) :: u_dev , v_dev , w_dev , & du_dev , dv_dev , dw_dev type ( cuda_tdsops_t ), pointer :: der1st , der1st_sym , der2nd , der2nd_sym call resolve_field_t ( u_dev , u ) call resolve_field_t ( v_dev , v ) call resolve_field_t ( w_dev , w ) call resolve_field_t ( du_dev , du ) call resolve_field_t ( dv_dev , dv ) call resolve_field_t ( dw_dev , dw ) select type ( tdsops => dirps % der1st ) type is ( cuda_tdsops_t ); der1st => tdsops end select select type ( tdsops => dirps % der1st_sym ) type is ( cuda_tdsops_t ); der1st_sym => tdsops end select select type ( tdsops => dirps % der2nd ) type is ( cuda_tdsops_t ); der2nd => tdsops end select select type ( tdsops => dirps % der2nd_sym ) type is ( cuda_tdsops_t ); der2nd_sym => tdsops end select call transeq_halo_exchange ( self , u_dev , v_dev , w_dev , dirps % dir ) call transeq_dist_component ( self , du_dev , u_dev , u_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st , der1st_sym , der2nd , dirps % dir , & blocks , threads ) call transeq_dist_component ( self , dv_dev , v_dev , u_dev , & self % v_recv_s_dev , self % v_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st_sym , der1st , der2nd_sym , dirps % dir , & blocks , threads ) call transeq_dist_component ( self , dw_dev , w_dev , u_dev , & self % w_recv_s_dev , self % w_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st_sym , der1st , der2nd_sym , dirps % dir , & blocks , threads ) end subroutine transeq_cuda_dist subroutine transeq_halo_exchange ( self , u_dev , v_dev , w_dev , dir ) class ( cuda_backend_t ) :: self real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev , v_dev , w_dev integer , intent ( in ) :: dir integer :: n_halo , n , nproc_dir , pprev , pnext integer :: n_groups ! TODO: don't hardcode n_halo n_halo = 4 n_groups = self % mesh % get_n_groups ( dir ) n = self % mesh % get_n ( dir , VERT ) nproc_dir = self % mesh % par % nproc_dir ( dir ) pprev = self % mesh % par % pprev ( dir ) pnext = self % mesh % par % pnext ( dir ) ! Copy halo data into buffer arrays call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , n ) call copy_into_buffers ( self % v_send_s_dev , self % v_send_e_dev , v_dev , n ) call copy_into_buffers ( self % w_send_s_dev , self % w_send_e_dev , w_dev , n ) ! halo exchange call sendrecv_3fields ( & self % u_recv_s_dev , self % u_recv_e_dev , & self % v_recv_s_dev , self % v_recv_e_dev , & self % w_recv_s_dev , self % w_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & self % v_send_s_dev , self % v_send_e_dev , & self % w_send_s_dev , self % w_send_e_dev , & SZ * n_halo * n_groups , nproc_dir , pprev , pnext ) end subroutine transeq_halo_exchange subroutine transeq_dist_component ( self , rhs_dev , u_dev , conv_dev , & u_recv_s_dev , u_recv_e_dev , & conv_recv_s_dev , conv_recv_e_dev , & tdsops_du , tdsops_dud , tdsops_d2u , & dir , blocks , threads ) !! Computes RHS_x&#94;u following: !! !! rhs_x&#94;u = -0.5*(conv*du/dx + d(u*conv)/dx) + nu*d2u/dx2 class ( cuda_backend_t ) :: self real ( dp ), device , dimension (:, :, :), intent ( inout ) :: rhs_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev , conv_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: & u_recv_s_dev , u_recv_e_dev , & conv_recv_s_dev , conv_recv_e_dev class ( cuda_tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u integer , intent ( in ) :: dir type ( dim3 ), intent ( in ) :: blocks , threads class ( field_t ), pointer :: du , dud , d2u real ( dp ), device , pointer , dimension (:, :, :) :: & du_dev , dud_dev , d2u_dev ! Get some fields for storing the intermediate results du => self % allocator % get_block ( dir , VERT ) dud => self % allocator % get_block ( dir , VERT ) d2u => self % allocator % get_block ( dir , VERT ) call resolve_field_t ( du_dev , du ) call resolve_field_t ( dud_dev , dud ) call resolve_field_t ( d2u_dev , d2u ) call exec_dist_transeq_3fused ( & rhs_dev , & u_dev , u_recv_s_dev , u_recv_e_dev , & conv_dev , conv_recv_s_dev , conv_recv_e_dev , & du_dev , dud_dev , d2u_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & self % dud_send_s_dev , self % dud_send_e_dev , & self % dud_recv_s_dev , self % dud_recv_e_dev , & self % d2u_send_s_dev , self % d2u_send_e_dev , & self % d2u_recv_s_dev , self % d2u_recv_e_dev , & tdsops_du , tdsops_d2u , self % nu , & self % mesh % par % nproc_dir ( dir ), self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir ), blocks , threads & ) ! Release temporary blocks call self % allocator % release_block ( du ) call self % allocator % release_block ( dud ) call self % allocator % release_block ( d2u ) end subroutine transeq_dist_component subroutine transeq_cuda_thom ( self , du , dv , dw , u , v , w , dirps ) !! Thomas algorithm implementation. So much more easier than the !! distributed algorithm. It is intended to work only on a single rank !! so there is no MPI communication. implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_cuda_thom subroutine tds_solve_cuda ( self , du , u , dirps , tdsops ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ) :: blocks , threads ! Check if direction matches for both in/out fields and dirps if ( dirps % dir /= du % dir . or . u % dir /= du % dir ) then error stop 'DIR mismatch between fields and dirps in tds_solve.' end if blocks = dim3 ( self % mesh % get_n_groups ( u ), 1 , 1 ); threads = dim3 ( SZ , 1 , 1 ) call tds_solve_dist ( self , du , u , dirps , tdsops , blocks , threads ) end subroutine tds_solve_cuda subroutine tds_solve_dist ( self , du , u , dirps , tdsops , blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ), intent ( in ) :: blocks , threads real ( dp ), device , pointer , dimension (:, :, :) :: du_dev , u_dev type ( cuda_tdsops_t ), pointer :: tdsops_dev integer :: n_halo , n_groups , dir ! TODO: don't hardcode n_halo n_halo = 4 dir = u % dir n_groups = self % mesh % get_n_groups ( u ) call resolve_field_t ( du_dev , du ) call resolve_field_t ( u_dev , u ) select type ( tdsops ) type is ( cuda_tdsops_t ); tdsops_dev => tdsops end select call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , & tdsops_dev % tds_n ) call sendrecv_fields ( self % u_recv_s_dev , self % u_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & SZ * n_halo * n_groups , & self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir )) ! call exec_dist call exec_dist_tds_compact ( & du_dev , u_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & tdsops_dev , self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), self % mesh % par % pnext ( dir ), & blocks , threads & ) end subroutine tds_solve_dist subroutine reorder_cuda ( self , u_o , u_i , direction ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_o class ( field_t ), intent ( in ) :: u_i integer , intent ( in ) :: direction real ( dp ), device , pointer , dimension (:, :, :) :: u_o_d , u_i_d , u_temp_d class ( field_t ), pointer :: u_temp type ( dim3 ) :: blocks , threads integer :: nx_padded , ny_padded , nz_padded integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_o_d , u_o ) call resolve_field_t ( u_i_d , u_i ) dims_padded = self % mesh % get_padded_dims ( DIR_C ) nx_padded = dims_padded ( 1 ) ny_padded = dims_padded ( 2 ) nz_padded = dims_padded ( 3 ) select case ( direction ) case ( RDR_X2Y ) blocks = dim3 ( nx_padded / SZ , nz_padded , ny_padded / SZ ) threads = dim3 ( SZ , SZ , 1 ) call reorder_x2y <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_X2Z ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_x2z <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2X ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_y2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2Z ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_y2z <<< blocks , threads >>> ( u_o_d , u_i_d , & !& nx_padded , nz_padded ) case ( RDR_Z2X ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_z2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Z2Y ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_z2y <<< blocks , threads >>> ( u_o_d , u_i_d , & !& nx_padded , nz_padded ) case ( RDR_C2X ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_c2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_C2Y ) ! First reorder from C to X, then from X to Y u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_c2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded / SZ , nz_padded , ny_padded / SZ ) threads = dim3 ( SZ , SZ , 1 ) call reorder_x2y <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_C2Z ) ! First reorder from C to X, then from X to Z u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_c2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_x2z <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_X2C ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2C ) ! First reorder from Y to X, then from X to C u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_y2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_Z2C ) ! First reorder from Z to X, then from X to C u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_z2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( SZ , SZ , 1 ) call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case default error stop 'Reorder direction is undefined.' end select end subroutine reorder_cuda subroutine sum_yintox_cuda ( self , u , u_y ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_y real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_y_d type ( dim3 ) :: blocks , threads integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_d , u ) call resolve_field_t ( u_y_d , u_y ) dims_padded = self % mesh % get_padded_dims ( DIR_C ) blocks = dim3 ( dims_padded ( 1 ) / SZ , dims_padded ( 2 ) / SZ , dims_padded ( 3 )) threads = dim3 ( SZ , SZ , 1 ) call sum_yintox <<< blocks , threads >>> ( u_d , u_y_d , dims_padded ( 3 )) !& end subroutine sum_yintox_cuda subroutine sum_zintox_cuda ( self , u , u_z ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_z real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_z_d type ( dim3 ) :: blocks , threads integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_d , u ) call resolve_field_t ( u_z_d , u_z ) dims_padded = self % mesh % get_padded_dims ( DIR_C ) blocks = dim3 ( dims_padded ( 1 ), dims_padded ( 2 ) / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call sum_zintox <<< blocks , threads >>> ( u_d , u_z_d , dims_padded ( 3 )) !& end subroutine sum_zintox_cuda subroutine vecadd_cuda ( self , a , x , b , y ) implicit none class ( cuda_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d type ( dim3 ) :: blocks , threads integer :: nx call resolve_field_t ( x_d , x ) call resolve_field_t ( y_d , y ) nx = size ( x_d , dim = 2 ) blocks = dim3 ( size ( x_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call axpby <<< blocks , threads >>> ( nx , a , x_d , b , y_d ) !& end subroutine vecadd_cuda real ( dp ) function scalar_product_cuda ( self , x , y ) result ( s ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d real ( dp ), device , allocatable :: sum_d type ( dim3 ) :: blocks , threads integer :: n , ierr call resolve_field_t ( x_d , x ) call resolve_field_t ( y_d , y ) allocate ( sum_d ) sum_d = 0._dp n = size ( x_d , dim = 2 ) blocks = dim3 ( size ( x_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call scalar_product <<< blocks , threads >>> ( sum_d , x_d , y_d , n ) !& s = sum_d call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_DOUBLE_PRECISION , MPI_SUM , & MPI_COMM_WORLD , ierr ) end function scalar_product_cuda subroutine copy_into_buffers ( u_send_s_dev , u_send_e_dev , u_dev , n ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: u_send_s_dev , & u_send_e_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev integer , intent ( in ) :: n type ( dim3 ) :: blocks , threads integer :: n_halo = 4 blocks = dim3 ( size ( u_dev , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call buffer_copy <<< blocks , threads >>> ( u_send_s_dev , u_send_e_dev , & !& u_dev , n , n_halo ) end subroutine copy_into_buffers subroutine copy_data_to_f_cuda ( self , f , data ) class ( cuda_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( inout ) :: data select type ( f ); type is ( cuda_field_t ); f % data_d = data ; end select end subroutine copy_data_to_f_cuda subroutine copy_f_to_data_cuda ( self , data , f ) class ( cuda_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f select type ( f ); type is ( cuda_field_t ); data = f % data_d ; end select end subroutine copy_f_to_data_cuda subroutine init_cuda_poisson_fft ( self , mesh , xdirps , ydirps , zdirps ) implicit none class ( cuda_backend_t ) :: self class ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps allocate ( cuda_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( cuda_poisson_fft_t ) poisson_fft = cuda_poisson_fft_t ( mesh , xdirps , ydirps , zdirps ) end select end subroutine init_cuda_poisson_fft subroutine resolve_field_t ( u_dev , u ) real ( dp ), device , pointer , dimension (:, :, :), intent ( out ) :: u_dev class ( field_t ), intent ( in ) :: u select type ( u ) type is ( cuda_field_t ) u_dev => u % data_d end select end subroutine resolve_field_t end module m_cuda_backend","tags":"","loc":"sourcefile/backend.f90~2.html"},{"title":"backend.f90 – x3d2","text":"Source Code module m_base_backend use mpi use m_allocator , only : allocator_t , field_t use m_common , only : dp , DIR_C , get_rdr_from_dirs use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : tdsops_t , dirps_t use m_mesh , only : mesh_t implicit none type , abstract :: base_backend_t !! base_backend class defines all the abstract operations that the !! solver class requires. !! !! For example, transport equation in solver class evaluates the !! derivatives in x, y, and z directions, and reorders the input !! fields as required. Then finally, combines all the directional !! derivatives to obtain the divergence of U*. !! !! All these high level operations solver class executes are !! defined here using the abstract interfaces. Every backend !! implementation extends the present abstact backend class to !! define the specifics of these operations based on the target !! architecture. real ( dp ) :: nu class ( mesh_t ), pointer :: mesh class ( allocator_t ), pointer :: allocator class ( poisson_fft_t ), pointer :: poisson_fft contains procedure ( transeq_ders ), deferred :: transeq_x procedure ( transeq_ders ), deferred :: transeq_y procedure ( transeq_ders ), deferred :: transeq_z procedure ( tds_solve ), deferred :: tds_solve procedure ( reorder ), deferred :: reorder procedure ( sum_intox ), deferred :: sum_yintox procedure ( sum_intox ), deferred :: sum_zintox procedure ( vecadd ), deferred :: vecadd procedure ( scalar_product ), deferred :: scalar_product procedure ( copy_data_to_f ), deferred :: copy_data_to_f procedure ( copy_f_to_data ), deferred :: copy_f_to_data procedure ( alloc_tdsops ), deferred :: alloc_tdsops procedure ( init_poisson_fft ), deferred :: init_poisson_fft procedure :: base_init procedure :: get_field_data procedure :: set_field_data end type base_backend_t abstract interface subroutine transeq_ders ( self , du , dv , dw , u , v , w , dirps ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_ders end interface abstract interface subroutine tds_solve ( self , du , u , dirps , tdsops ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u type ( dirps_t ), intent ( in ) :: dirps class ( tdsops_t ), intent ( in ) :: tdsops end subroutine tds_solve end interface abstract interface subroutine reorder ( self , u_ , u , direction ) !! reorder subroutines are straightforward, they rearrange !! data into our specialist data structure so that regardless !! of the direction tridiagonal systems are solved efficiently !! and fast. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction end subroutine reorder end interface abstract interface subroutine sum_intox ( self , u , u_ ) !! sum9into3 subroutine combines all the directional velocity !! derivatives into the corresponding x directional fields. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ end subroutine sum_intox end interface abstract interface subroutine vecadd ( self , a , x , b , y ) !! adds two vectors together: y = a*x + b*y import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y end subroutine vecadd end interface abstract interface real ( dp ) function scalar_product ( self , x , y ) result ( s ) !! Calculates the scalar product of two input fields import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y end function scalar_product end interface abstract interface subroutine copy_data_to_f ( self , f , data ) !! Copy the specialist data structure from device or host back !! to a regular 3D data array in host memory. import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: data end subroutine copy_data_to_f subroutine copy_f_to_data ( self , data , f ) !! Copy a regular 3D array in host memory into the specialist !! data structure field that lives on device or host import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f end subroutine copy_f_to_data end interface abstract interface subroutine alloc_tdsops ( self , tdsops , dir , operation , scheme , n_halo , & from_to , bc_start , bc_end , sym , c_nu , nu0_nu ) import :: base_backend_t import :: dp import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: dir character ( * ), intent ( in ) :: operation , scheme integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to , bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu end subroutine alloc_tdsops end interface abstract interface subroutine init_poisson_fft ( self , mesh , xdirps , ydirps , zdirps ) import :: base_backend_t import :: dirps_t import :: mesh_t implicit none class ( base_backend_t ) :: self class ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps end subroutine init_poisson_fft end interface contains subroutine base_init ( self ) implicit none class ( base_backend_t ) :: self end subroutine base_init subroutine get_field_data ( self , data , f , dir ) !! Extract data from field `f` optionally reordering into `dir` orientation. !! To output in same orientation as `f`, use `call ...%get_field_data(data, f, f%dir)` implicit none class ( base_backend_t ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data !! Output array class ( field_t ), intent ( in ) :: f !! Field integer , optional , intent ( in ) :: dir !! Desired orientation of output array (defaults to Cartesian) class ( field_t ), pointer :: f_temp integer :: direction , rdr_dir if ( present ( dir )) then direction = dir else direction = DIR_C end if ! Returns 0 if no reorder required rdr_dir = get_rdr_from_dirs ( f % dir , direction ) ! Carry out a reorder if we need, and copy from field to data array if ( rdr_dir /= 0 ) then f_temp => self % allocator % get_block ( direction ) call self % reorder ( f_temp , f , rdr_dir ) call self % copy_f_to_data ( data , f_temp ) call self % allocator % release_block ( f_temp ) else call self % copy_f_to_data ( data , f ) end if end subroutine get_field_data subroutine set_field_data ( self , f , data , dir ) implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: f !! Field real ( dp ), dimension (:, :, :), intent ( in ) :: data !! Input array integer , optional , intent ( in ) :: dir !! Orientation of input array (defaults to Cartesian) class ( field_t ), pointer :: f_temp integer :: direction , rdr_dir if ( present ( dir )) then direction = dir else direction = DIR_C end if ! Returns 0 if no reorder required rdr_dir = get_rdr_from_dirs ( direction , f % dir ) ! Carry out a reorder if we need, and copy from data array to field if ( rdr_dir /= 0 ) then f_temp => self % allocator % get_block ( direction ) call self % copy_data_to_f ( f_temp , data ) call self % reorder ( f , f_temp , rdr_dir ) call self % allocator % release_block ( f_temp ) else call self % copy_data_to_f ( f , data ) end if end subroutine set_field_data end module m_base_backend","tags":"","loc":"sourcefile/backend.f90~3.html"},{"title":"sendrecv.f90 – x3d2","text":"Source Code module m_cuda_sendrecv use cudafor use mpi use m_common , only : dp implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields subroutine sendrecv_3fields ( & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e , & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e , & n_data , nproc , prev , next & ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 12 ), err ( 12 ), ierr , tag = 1234 if ( nproc == 1 ) then f1_recv_s = f1_send_e f1_recv_e = f1_send_s f2_recv_s = f2_send_e f2_recv_e = f2_send_s f3_recv_s = f3_send_e f3_recv_e = f3_send_s else call MPI_Isend ( f1_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f1_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f1_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f1_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Isend ( f2_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 5 ), err ( 5 )) call MPI_Irecv ( f2_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 6 ), err ( 6 )) call MPI_Isend ( f2_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 7 ), err ( 7 )) call MPI_Irecv ( f2_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 8 ), err ( 8 )) call MPI_Isend ( f3_send_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 9 ), err ( 9 )) call MPI_Irecv ( f3_recv_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 10 ), err ( 10 )) call MPI_Isend ( f3_send_e , n_data , MPI_DOUBLE_PRECISION , & next , tag , MPI_COMM_WORLD , req ( 11 ), err ( 11 )) call MPI_Irecv ( f3_recv_s , n_data , MPI_DOUBLE_PRECISION , & prev , tag , MPI_COMM_WORLD , req ( 12 ), err ( 12 )) call MPI_Waitall ( 12 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_3fields end module m_cuda_sendrecv","tags":"","loc":"sourcefile/sendrecv.f90~2.html"},{"title":"distributed.f90 – x3d2","text":"Source Code module m_cuda_kernels_dist use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , coeffs_s , coeffs_e , coeffs , n , & ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , send_u_s , & send_u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e real ( dp ), device , intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e real ( dp ), device , intent ( in ), dimension (:) :: coeffs integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j , b , k , lj integer :: jm2 , jm1 , jp1 , jp2 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & temp_du , alpha , last_r i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) du ( i , 1 , b ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = du ( i , 1 , b ) * faf ( 1 ) du ( i , 2 , b ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = du ( i , 2 , b ) * faf ( 2 ) du ( i , 3 , b ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = ffr ( 3 ) * ( du ( i , 3 , b ) - faf ( 3 ) * du ( i , 2 , b )) du ( i , 4 , b ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = ffr ( 4 ) * ( du ( i , 4 , b ) - faf ( 3 ) * du ( i , 3 , b )) alpha = faf ( 5 ) do j = 5 , n - 4 temp_du = c_m4 * u ( i , j - 4 , b ) + c_m3 * u ( i , j - 3 , b ) & + c_m2 * u ( i , j - 2 , b ) + c_m1 * u ( i , j - 1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , j + 1 , b ) + c_p2 * u ( i , j + 2 , b ) & + c_p3 * u ( i , j + 3 , b ) + c_p4 * u ( i , j + 4 , b ) du ( i , j , b ) = ffr ( j ) * ( temp_du - alpha * du ( i , j - 1 , b )) end do j = n - 3 du ( i , j , b ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n - 2 du ( i , j , b ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n - 1 du ( i , j , b ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n du ( i , j , b ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) send_u_e ( i , 1 , b ) = du ( i , n , b ) ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - fbc ( j ) * du ( i , j + 1 , b ) end do du ( i , 1 , b ) = last_r * ( du ( i , 1 , b ) - fbc ( 1 ) * du ( i , 2 , b )) send_u_s ( i , 1 , b ) = du ( i , 1 , b ) end subroutine der_univ_dist attributes ( global ) subroutine der_univ_subs ( du , recv_u_s , recv_u_e , & n , dist_sa , dist_sc ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: recv_u_s , recv_u_e real ( dp ), device , intent ( in ), dimension (:) :: dist_sa , dist_sc integer , value , intent ( in ) :: n ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp , du_s , du_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( du ( i , 1 , b ) - bl * recv_u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( du ( i , n , b ) - ur * recv_u_e ( i , 1 , b )) du ( i , 1 , b ) = du_s do j = 2 , n - 1 du ( i , j , b ) = ( du ( i , j , b ) - dist_sa ( j ) * du_s - dist_sc ( j ) * du_e ) end do du ( i , n , b ) = du_e end subroutine der_univ_subs attributes ( global ) subroutine transeq_3fused_dist ( & du , dud , d2u , & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e , & u , u_s , u_e , v , v_s , v_e , n , & d1_coeffs_s , d1_coeffs_e , d1_coeffs , d1_fw , d1_bw , d1_af , & d2_coeffs_s , d2_coeffs_e , d2_coeffs , d2_fw , d2_bw , d2_af & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , dud , d2u real ( dp ), device , intent ( out ), dimension (:, :, :) :: & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e , & v , v_s , v_e integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ) :: d1_coeffs_s (:, :), d1_coeffs_e (:, :), & d1_coeffs (:) real ( dp ), device , intent ( in ) :: d1_fw (:), d1_bw (:), d1_af (:) real ( dp ), device , intent ( in ) :: d2_coeffs_s (:, :), d2_coeffs_e (:, :), & d2_coeffs (:) real ( dp ), device , intent ( in ) :: d2_fw (:), d2_bw (:), d2_af (:) ! Local variables integer :: i , j , b real ( dp ) :: d1_c_m4 , d1_c_m3 , d1_c_m2 , d1_c_m1 , d1_c_j , & d1_c_p1 , d1_c_p2 , d1_c_p3 , d1_c_p4 , & d1_alpha , d1_last_r real ( dp ) :: d2_c_m4 , d2_c_m3 , d2_c_m2 , d2_c_m1 , d2_c_j , & d2_c_p1 , d2_c_p2 , d2_c_p3 , d2_c_p4 , & d2_alpha , d2_last_r real ( dp ) :: temp_du , temp_dud , temp_d2u real ( dp ) :: u_m4 , u_m3 , u_m2 , u_m1 , u_j , u_p1 , u_p2 , u_p3 , u_p4 real ( dp ) :: v_m4 , v_m3 , v_m2 , v_m1 , v_j , v_p1 , v_p2 , v_p3 , v_p4 real ( dp ) :: old_du , old_dud , old_d2u i = threadIdx % x b = blockIdx % x d1_last_r = d1_fw ( 1 ) d2_last_r = d2_fw ( 1 ) ! j = 1 temp_du = d1_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + d1_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + d1_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = temp_du * d1_af ( 1 ) temp_dud = d1_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) * v_s ( i , 1 , b ) & + d1_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + d1_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) * v ( i , 5 , b ) dud ( i , 1 , b ) = temp_dud * d1_af ( 1 ) temp_d2u = d2_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + d2_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + d2_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) d2u ( i , 1 , b ) = temp_d2u * d2_af ( 1 ) ! j = 2 temp_du = d1_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + d1_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = temp_du * d1_af ( 2 ) temp_dud = d1_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + d1_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) * v ( i , 6 , b ) dud ( i , 2 , b ) = temp_dud * d1_af ( 2 ) temp_d2u = d2_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + d2_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) d2u ( i , 2 , b ) = temp_d2u * d2_af ( 2 ) ! j = 3 temp_du = d1_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + d1_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + d1_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = d1_fw ( 3 ) * ( temp_du - d1_af ( 3 ) * du ( i , 2 , b )) temp_dud = d1_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + d1_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + d1_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) * v ( i , 7 , b ) dud ( i , 3 , b ) = d1_fw ( 3 ) * ( temp_dud - d1_af ( 3 ) * dud ( i , 2 , b )) temp_d2u = d2_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + d2_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + d2_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) d2u ( i , 3 , b ) = d2_fw ( 3 ) * ( temp_d2u - d2_af ( 3 ) * d2u ( i , 2 , b )) ! j = 4 temp_du = d1_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + d1_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + d1_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + d1_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + d1_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + d1_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + d1_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + d1_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + d1_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = d1_fw ( 4 ) * ( temp_du - d1_af ( 3 ) * du ( i , 3 , b )) temp_dud = d1_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + d1_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + d1_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + d1_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + d1_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + d1_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + d1_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + d1_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) * v ( i , 7 , b ) & + d1_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) * v ( i , 8 , b ) dud ( i , 4 , b ) = d1_fw ( 4 ) * ( temp_dud - d1_af ( 3 ) * dud ( i , 3 , b )) temp_d2u = d2_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + d2_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + d2_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + d2_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + d2_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + d2_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + d2_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + d2_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + d2_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) d2u ( i , 4 , b ) = d2_fw ( 4 ) * ( temp_d2u - d2_af ( 3 ) * d2u ( i , 3 , b )) d1_alpha = d1_af ( 5 ) d2_alpha = d2_af ( 5 ) ! store bulk coeffs in the registers d1_c_m4 = d1_coeffs ( 1 ); d1_c_m3 = d1_coeffs ( 2 ) d1_c_m2 = d1_coeffs ( 3 ); d1_c_m1 = d1_coeffs ( 4 ) d1_c_j = d1_coeffs ( 5 ) d1_c_p1 = d1_coeffs ( 6 ); d1_c_p2 = d1_coeffs ( 7 ) d1_c_p3 = d1_coeffs ( 8 ); d1_c_p4 = d1_coeffs ( 9 ) d2_c_m4 = d2_coeffs ( 1 ); d2_c_m3 = d2_coeffs ( 2 ) d2_c_m2 = d2_coeffs ( 3 ); d2_c_m1 = d2_coeffs ( 4 ) d2_c_j = d2_coeffs ( 5 ) d2_c_p1 = d2_coeffs ( 6 ); d2_c_p2 = d2_coeffs ( 7 ) d2_c_p3 = d2_coeffs ( 8 ); d2_c_p4 = d2_coeffs ( 9 ) ! It is better to access d?(i, j - 1, b) via old_d? old_du = du ( i , 4 , b ) old_dud = dud ( i , 4 , b ) old_d2u = d2u ( i , 4 , b ) ! Populate registers with the u and v stencils u_m4 = u ( i , 1 , b ); u_m3 = u ( i , 2 , b ) u_m2 = u ( i , 3 , b ); u_m1 = u ( i , 4 , b ) u_j = u ( i , 5 , b ); u_p1 = u ( i , 6 , b ) u_p2 = u ( i , 7 , b ); u_p3 = u ( i , 8 , b ) v_m4 = v ( i , 1 , b ); v_m3 = v ( i , 2 , b ) v_m2 = v ( i , 3 , b ); v_m1 = v ( i , 4 , b ) v_j = v ( i , 5 , b ); v_p1 = v ( i , 6 , b ) v_p2 = v ( i , 7 , b ); v_p3 = v ( i , 8 , b ) do j = 5 , n - 4 u_p4 = u ( i , j + 4 , b ); v_p4 = v ( i , j + 4 , b ) ! du temp_du = d1_c_m4 * u_m4 + d1_c_m3 * u_m3 + d1_c_m2 * u_m2 + d1_c_m1 * u_m1 & + d1_c_j * u_j & + d1_c_p1 * u_p1 + d1_c_p2 * u_p2 + d1_c_p3 * u_p3 + d1_c_p4 * u_p4 du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_alpha * old_du ) old_du = du ( i , j , b ) ! dud temp_dud = d1_c_m4 * u_m4 * v_m4 + d1_c_m3 * u_m3 * v_m3 & + d1_c_m2 * u_m2 * v_m2 + d1_c_m1 * u_m1 * v_m1 & + d1_c_j * u_j * v_j & + d1_c_p1 * u_p1 * v_p1 + d1_c_p2 * u_p2 * v_p2 & + d1_c_p3 * u_p3 * v_p3 + d1_c_p4 * u_p4 * v_p4 dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_alpha * old_dud ) old_dud = dud ( i , j , b ) ! d2u temp_d2u = d2_c_m4 * u_m4 + d2_c_m3 * u_m3 + d2_c_m2 * u_m2 + d2_c_m1 * u_m1 & + d2_c_j * u_j & + d2_c_p1 * u_p1 + d2_c_p2 * u_p2 + d2_c_p3 * u_p3 + d2_c_p4 * u_p4 d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_alpha * old_d2u ) old_d2u = d2u ( i , j , b ) ! Prepare registers for the next step u_m4 = u_m3 ; u_m3 = u_m2 ; u_m2 = u_m1 ; u_m1 = u_j u_j = u_p1 ; u_p1 = u_p2 ; u_p2 = u_p3 ; u_p3 = u_p4 v_m4 = v_m3 ; v_m3 = v_m2 ; v_m2 = v_m1 ; v_m1 = v_j v_j = v_p1 ; v_p1 = v_p2 ; v_p2 = v_p3 ; v_p3 = v_p4 end do j = n - 3 temp_du = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + d1_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 1 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) * v ( i , j + 3 , b ) & + d1_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d1_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + d2_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + d2_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n - 2 temp_du = d1_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 2 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + d1_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + d2_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n - 1 temp_du = d1_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + d1_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 3 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + d1_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + d1_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + d2_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + d2_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) j = n temp_du = d1_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + d1_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + d1_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + d1_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + d1_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = d1_fw ( j ) * ( temp_du - d1_af ( j ) * du ( i , j - 1 , b )) temp_dud = d1_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + d1_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + d1_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + d1_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + d1_coeffs_e ( 5 , 4 ) * u ( i , j , b ) * v ( i , j , b ) & + d1_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + d1_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + d1_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) & + d1_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) * v_e ( i , 4 , b ) dud ( i , j , b ) = d1_fw ( j ) * ( temp_dud - d1_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + d2_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + d2_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + d2_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + d2_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + d2_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + d2_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + d2_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + d2_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) d2u ( i , j , b ) = d2_fw ( j ) * ( temp_d2u - d2_af ( j ) * d2u ( i , j - 1 , b )) send_du_e ( i , 1 , b ) = du ( i , n , b ) send_dud_e ( i , 1 , b ) = dud ( i , n , b ) send_d2u_e ( i , 1 , b ) = d2u ( i , n , b ) ! Backward pass of the hybrid algorithm do j = n - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - d1_bw ( j ) * du ( i , j + 1 , b ) dud ( i , j , b ) = dud ( i , j , b ) - d1_bw ( j ) * dud ( i , j + 1 , b ) d2u ( i , j , b ) = d2u ( i , j , b ) - d2_bw ( j ) * d2u ( i , j + 1 , b ) end do du ( i , 1 , b ) = d1_last_r * ( du ( i , 1 , b ) - d1_bw ( 1 ) * du ( i , 2 , b )) dud ( i , 1 , b ) = d1_last_r * ( dud ( i , 1 , b ) - d1_bw ( 1 ) * dud ( i , 2 , b )) d2u ( i , 1 , b ) = d2_last_r * ( d2u ( i , 1 , b ) - d2_bw ( 1 ) * d2u ( i , 2 , b )) send_du_s ( i , 1 , b ) = du ( i , 1 , b ) send_dud_s ( i , 1 , b ) = dud ( i , 1 , b ) send_d2u_s ( i , 1 , b ) = d2u ( i , 1 , b ) end subroutine transeq_3fused_dist attributes ( global ) subroutine transeq_3fused_subs ( & r_u , conv , du , dud , d2u , & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e , & d1_sa , d1_sc , d2_sa , d2_sc , n , nu & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: r_u real ( dp ), device , intent ( in ), dimension (:, :, :) :: conv , du , dud , d2u real ( dp ), device , intent ( in ), dimension (:, :, :) :: & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e real ( dp ), device , intent ( in ), dimension (:) :: d1_sa , d1_sc , d2_sa , d2_sc integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: nu ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp real ( dp ) :: du_temp , dud_temp , d2u_temp real ( dp ) :: du_s , du_e , dud_s , dud_e , d2u_s , d2u_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' ! first derivative bl = d1_sa ( 1 ) ur = d1_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( du ( i , 1 , b ) - bl * recv_du_s ( i , 1 , b )) dud_s = recp * ( dud ( i , 1 , b ) - bl * recv_dud_s ( i , 1 , b )) ! second derivative bl = d2_sa ( 1 ) ur = d2_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_s = recp * ( d2u ( i , 1 , b ) - bl * recv_d2u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' ! first derivative bl = d1_sc ( n ) ur = d1_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( du ( i , n , b ) - ur * recv_du_e ( i , 1 , b )) dud_e = recp * ( dud ( i , n , b ) - ur * recv_dud_e ( i , 1 , b )) ! second derivative bl = d2_sc ( n ) ur = d2_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_e = recp * ( d2u ( i , n , b ) - ur * recv_d2u_e ( i , 1 , b )) ! final substitution r_u ( i , 1 , b ) = - 0.5_dp * ( conv ( i , 1 , b ) * du_s + dud_s ) + nu * d2u_s do j = 2 , n - 1 du_temp = ( du ( i , j , b ) - d1_sa ( j ) * du_s - d1_sc ( j ) * du_e ) dud_temp = ( dud ( i , j , b ) - d1_sa ( j ) * dud_s - d1_sc ( j ) * dud_e ) d2u_temp = ( d2u ( i , j , b ) - d2_sa ( j ) * d2u_s - d2_sc ( j ) * d2u_e ) r_u ( i , j , b ) = - 0.5_dp * ( conv ( i , j , b ) * du_temp + dud_temp ) & + nu * d2u_temp end do r_u ( i , n , b ) = - 0.5_dp * ( conv ( i , n , b ) * du_e + dud_e ) + nu * d2u_e end subroutine transeq_3fused_subs end module m_cuda_kernels_dist","tags":"","loc":"sourcefile/distributed.f90~2.html"},{"title":"exec_thom.f90 – x3d2","text":"Source Code module m_cuda_exec_thom use cudafor use m_common , only : dp use m_cuda_kernels_thom , only : der_univ_thom , der_univ_thom_per use m_cuda_tdsops , only : cuda_tdsops_t implicit none contains subroutine exec_thom_tds_compact ( du , u , tdsops , blocks , threads ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u type ( cuda_tdsops_t ), intent ( in ) :: tdsops type ( dim3 ), intent ( in ) :: blocks , threads if ( tdsops % periodic ) then call der_univ_thom_per <<< blocks , threads >>> ( & !& du , u , tdsops % coeffs_dev , tdsops % tds_n , tdsops % alpha , & tdsops % thom_f_dev , tdsops % thom_s_dev , & tdsops % thom_w_dev , tdsops % thom_p_dev & ) else call der_univ_thom <<< blocks , threads >>> ( & !& du , u , & tdsops % coeffs_s_dev , tdsops % coeffs_e_dev , tdsops % coeffs_dev , & tdsops % tds_n , tdsops % thom_f_dev , tdsops % thom_s_dev , & tdsops % thom_w_dev & ) end if end subroutine exec_thom_tds_compact end module m_cuda_exec_thom","tags":"","loc":"sourcefile/exec_thom.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"Source Code module m_cuda_poisson_fft use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use iso_fortran_env , only : stderr => error_unit use cudafor use cufftXt use cufft use mpi use m_allocator , only : field_t use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , CELL use m_mesh , only : mesh_t use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_cuda_allocator , only : cuda_field_t use m_cuda_spectral , only : process_spectral_div_u implicit none type , extends ( poisson_fft_t ) :: cuda_poisson_fft_t !! FFT based Poisson solver !> Local domain sized array storing the spectral equivalence constants complex ( dp ), device , allocatable , dimension (:, :, :) :: waves_dev !> Wave numbers in x, y, and z real ( dp ), device , allocatable , dimension (:) :: ax_dev , bx_dev , & ay_dev , by_dev , & az_dev , bz_dev !> Forward and backward FFT transform plans integer :: plan3D_fw , plan3D_bw !> cuFFTMp object manages decomposition and data storage type ( cudaLibXtDesc ), pointer :: xtdesc contains procedure :: fft_forward => fft_forward_cuda procedure :: fft_backward => fft_backward_cuda procedure :: fft_postprocess => fft_postprocess_cuda end type cuda_poisson_fft_t interface cuda_poisson_fft_t module procedure init end interface cuda_poisson_fft_t private :: init contains function init ( mesh , xdirps , ydirps , zdirps ) result ( poisson_fft ) implicit none class ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps type ( cuda_poisson_fft_t ) :: poisson_fft integer :: nx , ny , nz integer :: ierr integer ( int_ptr_kind ()) :: worksize call poisson_fft % base_init ( mesh , xdirps , ydirps , zdirps ) nx = poisson_fft % nx_glob ny = poisson_fft % ny_glob nz = poisson_fft % nz_glob allocate ( poisson_fft % waves_dev ( poisson_fft % nx_spec , & poisson_fft % ny_spec , & poisson_fft % nz_spec )) poisson_fft % waves_dev = poisson_fft % waves allocate ( poisson_fft % ax_dev ( nx ), poisson_fft % bx_dev ( nx )) allocate ( poisson_fft % ay_dev ( ny ), poisson_fft % by_dev ( ny )) allocate ( poisson_fft % az_dev ( nz ), poisson_fft % bz_dev ( nz )) poisson_fft % ax_dev = poisson_fft % ax ; poisson_fft % bx_dev = poisson_fft % bx poisson_fft % ay_dev = poisson_fft % ay ; poisson_fft % by_dev = poisson_fft % by poisson_fft % az_dev = poisson_fft % az ; poisson_fft % bz_dev = poisson_fft % bz ! 3D plans ierr = cufftCreate ( poisson_fft % plan3D_fw ) ierr = cufftMpAttachComm ( poisson_fft % plan3D_fw , CUFFT_COMM_MPI , & MPI_COMM_WORLD ) ierr = cufftMakePlan3D ( poisson_fft % plan3D_fw , nz , ny , nx , CUFFT_D2Z , & worksize ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Forward 3D FFT plan generation failed' end if ierr = cufftCreate ( poisson_fft % plan3D_bw ) ierr = cufftMpAttachComm ( poisson_fft % plan3D_bw , CUFFT_COMM_MPI , & MPI_COMM_WORLD ) ierr = cufftMakePlan3D ( poisson_fft % plan3D_bw , nz , ny , nx , CUFFT_Z2D , & worksize ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Backward 3D FFT plan generation failed' end if ! allocate storage for cuFFTMp ierr = cufftXtMalloc ( poisson_fft % plan3D_fw , poisson_fft % xtdesc , & CUFFT_XT_FORMAT_INPLACE ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'cufftXtMalloc failed' end if end function init subroutine fft_forward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), device , pointer :: flat_dev (:, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: ierr select type ( f ) type is ( cuda_field_t ) flat_dev ( 1 : self % nx_loc , 1 : self % ny_loc * self % nz_loc ) => f % data_d end select call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ self % nx_loc + 2 , self % ny_loc * self % nz_loc ]) ierr = cudaMemcpy2D ( d_dev , self % nx_loc + 2 , flat_dev , self % nx_loc , & self % nx_loc , self % ny_loc * self % nz_loc ) if ( ierr /= 0 ) then print * , 'cudaMemcpy2D error code: ' , ierr error stop 'cudaMemcpy2D failed' end if ierr = cufftXtExecDescriptor ( self % plan3D_fw , self % xtdesc , self % xtdesc , & CUFFT_FORWARD ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Forward 3D FFT execution failed' end if end subroutine fft_forward_cuda subroutine fft_backward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), device , pointer :: flat_dev (:, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: ierr ierr = cufftXtExecDescriptor ( self % plan3D_bw , self % xtdesc , self % xtdesc , & CUFFT_INVERSE ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Backward 3D FFT execution failed' end if select type ( f ) type is ( cuda_field_t ) flat_dev ( 1 : self % nx_loc , 1 : self % ny_loc * self % nz_loc ) => f % data_d end select call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ self % nx_loc + 2 , self % ny_loc * self % nz_loc ]) ierr = cudaMemcpy2D ( flat_dev , self % nx_loc , d_dev , self % nx_loc + 2 , & self % nx_loc , self % ny_loc * self % nz_loc ) if ( ierr /= 0 ) then print * , 'cudaMemcpy2D error code: ' , ierr error stop 'cudaMemcpy2D failed' end if end subroutine fft_backward_cuda subroutine fft_postprocess_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self type ( cudaXtDesc ), pointer :: descriptor complex ( dp ), device , dimension (:, :, :), pointer :: c_dev type ( dim3 ) :: blocks , threads integer :: tsize ! obtain a pointer to descriptor so that we can carry out postprocessing call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % ny_spec - 1 ) / tsize + 1 , self % nz_spec , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Postprocess div_u in spectral space call process_spectral_div_u <<< blocks , threads >>> ( & !& c_dev , self % waves_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) end subroutine fft_postprocess_cuda end module m_cuda_poisson_fft","tags":"","loc":"sourcefile/poisson_fft.f90~3.html"},{"title":"mesh.f90 – x3d2","text":"Source Code module m_mesh use iso_fortran_env , only : stderr => error_unit use mpi use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C , & CELL , VERT , none , X_FACE , Y_FACE , Z_FACE , & X_EDGE , Y_EDGE , Z_EDGE , & BC_PERIODIC , BC_NEUMANN , BC_DIRICHLET use m_field , only : field_t implicit none ! Stores geometry information type :: geo_t real ( dp ), dimension ( 3 ) :: d ! size of a cell in each direction (=edge length, distance between centers, distance between vertices) real ( dp ), dimension ( 3 ) :: L ! Global dimensions of the domain in each direction end type ! Stores parallel domain related information type :: parallel_t integer :: nrank ! local rank ID integer :: nproc ! total number of ranks/proc participating in the domain decomposition integer , dimension ( 3 ) :: nrank_dir ! local rank ID in each direction integer , dimension ( 3 ) :: nproc_dir ! total number of proc in each direction integer , dimension ( 3 ) :: n_offset ! number of cells offset in each direction due to domain decomposition integer , dimension ( 3 ) :: pnext ! rank ID of the previous rank in each direction integer , dimension ( 3 ) :: pprev ! rank ID of the next rank in each direction contains procedure :: is_root ! returns if the current rank is the root rank end type ! The mesh class stores all the information about the global and local (due to domain decomposition) mesh ! It also includes getter functions to access some of its parameters type :: mesh_t integer , dimension ( 3 ), private :: global_vert_dims ! global number of vertices in each direction without padding (cartesian structure) integer , dimension ( 3 ), private :: global_cell_dims ! global number of cells in each direction without padding (cartesian structure) integer , dimension ( 3 ), private :: vert_dims_padded ! local domain size including padding (cartesian structure) integer , dimension ( 3 ), private :: vert_dims ! local number of vertices in each direction without padding (cartesian structure) integer , dimension ( 3 ), private :: cell_dims ! local number of cells in each direction without padding (cartesian structure) logical , dimension ( 3 ), private :: periodic_BC ! Whether or not a direction has a periodic BC integer , dimension ( 3 , 2 ), private :: BCs_global integer , dimension ( 3 , 2 ), private :: BCs integer , private :: sz type ( geo_t ), allocatable :: geo ! object containing geometry information type ( parallel_t ), allocatable :: par ! object containing parallel domain decomposition information contains procedure :: get_SZ procedure :: get_dims procedure :: get_global_dims procedure :: get_n_groups_dir procedure :: get_n_groups_phi generic :: get_n_groups => get_n_groups_dir , get_n_groups_phi procedure :: get_field_dims_dir procedure :: get_field_dims_phi procedure :: get_field_dims_phi_dataloc generic :: get_field_dims => get_field_dims_dir , get_field_dims_phi , & get_field_dims_phi_dataloc procedure :: get_n_dir procedure :: get_n_phi generic :: get_n => get_n_dir , get_n_phi procedure :: get_padded_dims_phi procedure :: get_padded_dims_dir generic :: get_padded_dims => get_padded_dims_dir , get_padded_dims_phi procedure :: get_coordinates procedure :: set_sz procedure :: set_padded_dims end type mesh_t interface mesh_t module procedure mesh_init end interface mesh_t contains function mesh_init ( dims_global , nproc_dir , L_global , BC_x , BC_y , BC_z ) & result ( mesh ) !! Completely initialise the mesh object. !! Upon initialisation the mesh object can be read-only and shouldn't be edited !! Takes as argument global information about the mesh like its length, number of cells and decomposition in each direction integer , dimension ( 3 ), intent ( in ) :: dims_global integer , dimension ( 3 ), intent ( in ) :: nproc_dir ! Number of proc in each direction real ( dp ), dimension ( 3 ), intent ( in ) :: L_global character ( len =* ), dimension ( 2 ), intent ( in ) :: BC_x , BC_y , BC_z type ( mesh_t ) :: mesh character ( len = 20 ), dimension ( 3 , 2 ) :: BC_all logical :: is_first_domain , is_last_domain integer :: dir , j integer :: ierr allocate ( mesh % geo ) allocate ( mesh % par ) BC_all ( 1 , 1 ) = BC_x ( 1 ); BC_all ( 1 , 2 ) = BC_x ( 2 ) BC_all ( 2 , 1 ) = BC_y ( 1 ); BC_all ( 2 , 2 ) = BC_y ( 2 ) BC_all ( 3 , 1 ) = BC_z ( 1 ); BC_all ( 3 , 2 ) = BC_z ( 2 ) do dir = 1 , 3 do j = 1 , 2 select case ( trim ( BC_all ( dir , j ))) case ( 'periodic' ) mesh % BCs_global ( dir , j ) = BC_PERIODIC case ( 'neumann' ) mesh % BCs_global ( dir , j ) = BC_NEUMANN case ( 'dirichlet' ) mesh % BCs_global ( dir , j ) = BC_DIRICHLET case default error stop 'Unknown BC' end select end do end do do dir = 1 , 3 if ( any ( mesh % BCs_global ( dir , :) == BC_PERIODIC ) . and . & (. not . all ( mesh % BCs_global ( dir , :) == BC_PERIODIC ))) then error stop 'BCs are incompatible: in a direction make sure to have & &either both sides periodic or none.' end if mesh % periodic_BC ( dir ) = all ( mesh % BCs_global ( dir , :) == BC_PERIODIC ) end do ! Set global vertex dims mesh % global_vert_dims (:) = dims_global ! Set global cell dims do dir = 1 , 3 if ( mesh % periodic_BC ( dir )) then mesh % global_cell_dims ( dir ) = mesh % global_vert_dims ( dir ) else mesh % global_cell_dims ( dir ) = mesh % global_vert_dims ( dir ) - 1 end if end do ! Geometry mesh % geo % L = L_global mesh % geo % d = mesh % geo % L / mesh % global_cell_dims ! Parallel domain decomposition mesh % par % nproc_dir (:) = nproc_dir mesh % par % nproc = product ( nproc_dir (:)) call MPI_Comm_rank ( MPI_COMM_WORLD , mesh % par % nrank , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , mesh % par % nproc , ierr ) call domain_decomposition ( mesh ) ! Set subdomain BCs do dir = 1 , 3 is_first_domain = mesh % par % nrank_dir ( dir ) == 0 is_last_domain = mesh % par % nrank_dir ( dir ) + 1 == mesh % par % nproc_dir ( dir ) ! subdomain-subdomain boundaries are identical to periodic BCs if ( is_first_domain ) then mesh % BCs ( dir , 1 ) = mesh % BCs_global ( dir , 1 ) mesh % BCs ( dir , 2 ) = BC_PERIODIC else if ( is_last_domain ) then mesh % BCs ( dir , 1 ) = BC_PERIODIC mesh % BCs ( dir , 2 ) = mesh % BCs_global ( dir , 2 ) else mesh % BCs ( dir , :) = BC_PERIODIC end if end do ! Define number of cells and vertices in each direction mesh % vert_dims = mesh % global_vert_dims / mesh % par % nproc_dir do dir = 1 , 3 is_last_domain = ( mesh % par % nrank_dir ( dir ) + 1 == mesh % par % nproc_dir ( dir )) if ( is_last_domain . and . (. not . mesh % periodic_BC ( dir ))) then mesh % cell_dims ( dir ) = mesh % vert_dims ( dir ) - 1 else mesh % cell_dims ( dir ) = mesh % vert_dims ( dir ) end if end do ! Set offset for global indices mesh % par % n_offset (:) = mesh % vert_dims (:) * mesh % par % nrank_dir (:) ! Define default values mesh % vert_dims_padded = mesh % vert_dims mesh % sz = 1 end function mesh_init subroutine set_padded_dims ( self , vert_dims ) class ( mesh_t ), intent ( inout ) :: self integer , dimension ( 3 ), intent ( in ) :: vert_dims self % vert_dims_padded = vert_dims end subroutine subroutine set_sz ( self , sz ) class ( mesh_t ), intent ( inout ) :: self integer , intent ( in ) :: sz self % sz = sz end subroutine subroutine domain_decomposition ( mesh ) !! Supports 1D, 2D, and 3D domain decomposition. !! !! Current implementation allows only constant sub-domain size across a !! given direction. class ( mesh_t ), intent ( inout ) :: mesh integer , allocatable , dimension (:, :, :) :: global_ranks integer :: i , nproc_x , nproc_y , nproc_z , nproc integer , dimension ( 3 ) :: subd_pos , subd_pos_prev , subd_pos_next integer :: dir ! Number of processes on a direction basis nproc_x = mesh % par % nproc_dir ( 1 ) nproc_y = mesh % par % nproc_dir ( 2 ) nproc_z = mesh % par % nproc_dir ( 3 ) ! A 3D array corresponding to each region in the global domain allocate ( global_ranks ( nproc_x , nproc_y , nproc_z )) ! set the corresponding global rank for each sub-domain global_ranks = reshape ([( i , i = 0 , mesh % par % nproc - 1 )], & shape = [ nproc_x , nproc_y , nproc_z ]) ! subdomain position in the global domain subd_pos = findloc ( global_ranks , mesh % par % nrank ) ! local/directional position of the subdomain mesh % par % nrank_dir (:) = subd_pos (:) - 1 do dir = 1 , 3 nproc = mesh % par % nproc_dir ( dir ) subd_pos_prev (:) = subd_pos (:) subd_pos_prev ( dir ) = modulo ( subd_pos ( dir ) - 2 , nproc ) + 1 mesh % par % pprev ( dir ) = global_ranks ( subd_pos_prev ( 1 ), & subd_pos_prev ( 2 ), & subd_pos_prev ( 3 )) subd_pos_next (:) = subd_pos (:) subd_pos_next ( dir ) = modulo ( subd_pos ( dir ) - nproc , nproc ) + 1 mesh % par % pnext ( dir ) = global_ranks ( subd_pos_next ( 1 ), & subd_pos_next ( 2 ), & subd_pos_next ( 3 )) end do end subroutine domain_decomposition pure function get_sz ( self ) result ( sz ) !! Getter for parameter SZ class ( mesh_t ), intent ( in ) :: self integer :: sz sz = self % sz end function pure function get_dims ( self , data_loc ) result ( dims ) !! Getter for local domain dimensions class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims dims = get_dims_dataloc ( data_loc , self % vert_dims , self % cell_dims ) end function pure function get_global_dims ( self , data_loc ) result ( dims ) !! Getter for local domain dimensions class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims dims = get_dims_dataloc ( data_loc , self % global_vert_dims , & self % global_cell_dims ) end function pure function get_dims_dataloc ( data_loc , vert_dims , cell_dims ) result ( dims ) !! Getter for domain dimensions integer , intent ( in ) :: data_loc integer , dimension ( 3 ), intent ( in ) :: vert_dims , cell_dims integer , dimension ( 3 ) :: dims select case ( data_loc ) case ( VERT ) dims = vert_dims case ( CELL ) dims = cell_dims case ( X_FACE ) dims ( 1 ) = vert_dims ( 1 ) dims ( 2 : 3 ) = cell_dims ( 2 : 3 ) case ( Y_FACE ) dims ( 1 ) = cell_dims ( 1 ) dims ( 2 ) = vert_dims ( 2 ) dims ( 3 ) = cell_dims ( 3 ) case ( Z_FACE ) dims ( 1 : 2 ) = cell_dims ( 1 : 2 ) dims ( 3 ) = vert_dims ( 3 ) case ( X_EDGE ) dims ( 1 ) = cell_dims ( 1 ) dims ( 2 : 3 ) = vert_dims ( 2 : 3 ) case ( Y_EDGE ) dims ( 1 ) = vert_dims ( 1 ) dims ( 2 ) = cell_dims ( 2 ) dims ( 3 ) = vert_dims ( 3 ) case ( Z_EDGE ) dims ( 1 : 2 ) = vert_dims ( 1 : 2 ) dims ( 3 ) = cell_dims ( 3 ) case ( none ) error stop \"Unknown location in get_dims_dataloc\" end select end function get_dims_dataloc pure function get_padded_dims_dir ( self , dir ) result ( dims_padded ) !! Getter for padded dimensions with structure in `dir` direction class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: dir integer , dimension ( 3 ) :: dims_padded if ( dir == DIR_C ) then dims_padded = self % vert_dims_padded else dims_padded ( 1 ) = self % sz dims_padded ( 2 ) = self % vert_dims_padded ( dir ) dims_padded ( 3 ) = self % get_n_groups ( dir ) end if end function pure function get_padded_dims_phi ( self , phi ) result ( dims_padded ) !! Getter for padded dimensions for field phi !! Gets the field direction from the field itself class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer , dimension ( 3 ) :: dims_padded dims_padded = self % get_padded_dims ( phi % dir ) end function pure function get_n_groups_dir ( self , dir ) result ( n_groups ) !! Getter for the number of groups for fields in direction `dir` class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: dir integer :: n_groups n_groups = ( product ( self % vert_dims_padded (:)) / & self % vert_dims_padded ( dir )) / self % sz end function pure function get_n_groups_phi ( self , phi ) result ( n_groups ) !! Getter for the number of groups for fields phi class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer :: n_groups n_groups = self % get_n_groups ( phi % dir ) end function pure function get_field_dims_phi ( self , phi ) result ( dims ) !! Getter for the dimensions of field phi class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer , dimension ( 3 ) :: dims dims = self % get_field_dims ( phi % dir , phi % data_loc ) end function pure function get_field_dims_phi_dataloc ( self , phi , data_loc ) result ( dims ) !! Getter for the dimensions of field phi where data is located on `data_loc` class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims dims = self % get_field_dims ( phi % dir , data_loc ) end function pure function get_field_dims_dir ( self , dir , data_loc ) result ( dims ) !! Getter for the dimensions of an array directed along `dir` where data would be located on `data_loc` class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: dir integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims if ( dir == DIR_C ) then dims ( 1 ) = self % get_n ( DIR_X , data_loc ) dims ( 2 ) = self % get_n ( DIR_Y , data_loc ) dims ( 3 ) = self % get_n ( DIR_Z , data_loc ) else dims ( 1 ) = self % sz dims ( 2 ) = self % get_n ( dir , data_loc ) dims ( 3 ) = self % get_n_groups ( dir ) end if end function pure function get_n_phi ( self , phi ) result ( n ) !! Getter for the main dimension of field phi class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer :: n n = self % get_n ( phi % dir , phi % data_loc ) end function pure function get_n_dir ( self , dir , data_loc ) result ( n ) !! Getter for the main dimension a field oriented along `dir` with data on `data_loc` class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: dir integer , intent ( in ) :: data_loc integer :: n , n_cell , n_vert n_cell = self % cell_dims ( dir ) n_vert = self % vert_dims ( dir ) ! default to n_vert n = n_vert select case ( data_loc ) case ( CELL ) n = n_cell case ( VERT ) n = n_vert case ( X_FACE ) if ( dir /= DIR_X ) then n = n_cell end if case ( Y_FACE ) if ( dir /= DIR_Y ) then n = n_cell end if case ( Z_FACE ) if ( dir /= DIR_Z ) then n = n_cell end if case ( X_EDGE ) if ( dir == DIR_X ) then n = n_cell end if case ( Y_EDGE ) if ( dir == DIR_Y ) then n = n_cell end if case ( Z_EDGE ) if ( dir == DIR_Z ) then n = n_cell end if case ( none ) error stop \"Unknown direction in get_n_dir\" end select end function get_n_dir pure function get_coordinates ( self , i , j , k ) result ( xloc ) !! Get the physical location of a cell center with i,j,k local indices class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: i , j , k real ( dp ), dimension ( 3 ) :: xloc xloc ( 1 ) = ( i - 1 + self % par % n_offset ( 1 )) * self % geo % d ( 1 ) xloc ( 2 ) = ( j - 1 + self % par % n_offset ( 2 )) * self % geo % d ( 2 ) xloc ( 3 ) = ( k - 1 + self % par % n_offset ( 3 )) * self % geo % d ( 3 ) end function pure function is_root ( self ) result ( is_root_rank ) !! Returns whether or not the current rank is the root rank class ( parallel_t ), intent ( in ) :: self logical :: is_root_rank is_root_rank = ( self % nrank == 0 ) end function end module m_mesh","tags":"","loc":"sourcefile/mesh.f90.html"}]}